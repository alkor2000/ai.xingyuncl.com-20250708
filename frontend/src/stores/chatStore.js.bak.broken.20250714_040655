import { create } from 'zustand'
import apiClient from '../utils/api'

const useChatStore = create((set, get) => ({
  // ðŸ”¥ çŠ¶æ€åˆ†ç¦» - å¯¹è¯åˆ—è¡¨çŠ¶æ€ç‹¬ç«‹
  conversations: [],
  conversationsLoading: false,
  conversationsLoaded: false,
  
  // ðŸ”¥ å½“å‰å¯¹è¯çŠ¶æ€ç‹¬ç«‹
  currentConversationId: null,
  currentConversation: null,
  messagesLoading: false,
  
  // å…¶ä»–çŠ¶æ€ä¿æŒä¸å˜
  aiModels: [],
  userCredits: null,
  creditsLoading: false,
  
  // ðŸ”¥ æ¯ä¸ªå¯¹è¯çš„ç‹¬ç«‹çŠ¶æ€å’Œæ¶ˆæ¯ç¼“å­˜
  conversationStates: new Map(), // conversationId -> { typing, isStreaming, streamingMessageId, activeRequest, messages, tempMessages }
  
  // ðŸ”¥ èŽ·å–å½“å‰å¯¹è¯çš„æ¶ˆæ¯
  get messages() {
    const state = get()
    if (!state.currentConversationId) return []
    
    const convState = state.conversationStates.get(state.currentConversationId)
    return convState?.messages || []
  },
  
  // ðŸ”¥ è®¾ç½®å½“å‰å¯¹è¯çš„æ¶ˆæ¯
  setMessages: (messages) => {
    const state = get()
    if (!state.currentConversationId) return
    
    set(state => {
      const newStates = new Map(state.conversationStates)
      const convState = newStates.get(state.currentConversationId) || {}
      newStates.set(state.currentConversationId, { ...convState, messages })
      return { conversationStates: newStates }
    })
  },
  
  // ðŸ”¥ èŽ·å–ç‰¹å®šå¯¹è¯çš„çŠ¶æ€
  getConversationState: (conversationId) => {
    const state = get().conversationStates.get(conversationId)
    return state || { typing: false, isStreaming: false, streamingMessageId: null, activeRequest: null, messages: [], tempMessages: [] }
  },
  
  // ðŸ”¥ æ›´æ–°ç‰¹å®šå¯¹è¯çš„çŠ¶æ€
  updateConversationState: (conversationId, updates) => {
    set(state => {
      const newStates = new Map(state.conversationStates)
      const currentState = newStates.get(conversationId) || { typing: false, isStreaming: false, streamingMessageId: null, activeRequest: null, messages: [], tempMessages: [] }
      newStates.set(conversationId, { ...currentState, ...updates })
      return { conversationStates: newStates }
    })
  },
  
  // ðŸ”¥ èŽ·å–å½“å‰å¯¹è¯çš„ç”ŸæˆçŠ¶æ€
  get typing() {
    const state = get()
    return state.getConversationState(state.currentConversationId).typing
  },
  
  get isStreaming() {
    const state = get()
    return state.getConversationState(state.currentConversationId).isStreaming
  },
  
  get streamingMessageId() {
    const state = get()
    return state.getConversationState(state.currentConversationId).streamingMessageId
  },
  
  // ðŸ”¥ èŽ·å–ä¼šè¯åˆ—è¡¨ - åªåœ¨é¦–æ¬¡æˆ–æ‰‹åŠ¨åˆ·æ–°æ—¶è°ƒç”¨
  getConversations: async (force = false) => {
    const state = get()
    
    // å¦‚æžœå·²åŠ è½½è¿‡ä¸”ä¸æ˜¯å¼ºåˆ¶åˆ·æ–°ï¼Œè·³è¿‡
    if (state.conversationsLoaded && !force) {
      return state.conversations
    }
    
    set({ conversationsLoading: true })
    try {
      const response = await apiClient.get('/chat/conversations')
      set({ 
        conversations: response.data.data,
        conversationsLoading: false,
        conversationsLoaded: true
      })
      return response.data.data
    } catch (error) {
      console.error('èŽ·å–ä¼šè¯åˆ—è¡¨å¤±è´¥:', error)
      set({ conversationsLoading: false })
      throw error
    }
  },

  // èŽ·å–ç”¨æˆ·ç§¯åˆ†çŠ¶æ€ - æ”¹ä¸ºæŒ‰éœ€è°ƒç”¨ï¼Œä¸å†è‡ªåŠ¨å®šæ—¶åˆ·æ–°
  getUserCredits: async () => {
    set({ creditsLoading: true })
    try {
      const response = await apiClient.get('/chat/credits')
      set({ 
        userCredits: response.data.data,
        creditsLoading: false 
      })
      return response.data.data
    } catch (error) {
      console.error('èŽ·å–ç”¨æˆ·ç§¯åˆ†å¤±è´¥:', error)
      set({ creditsLoading: false })
    }
  },
  
  // ðŸ”¥ åˆ›å»ºæ–°ä¼šè¯ - æ”¯æŒä¸Šä¸‹æ–‡æ•°é‡å’Œtemperatureè®¾ç½®
  createConversation: async (conversationData) => {
    set({ conversationsLoading: true })
    try {
      // åˆ›å»ºä¼šè¯å‰ç¡®ä¿æœ‰ç§¯åˆ†çŠ¶æ€ç”¨äºŽéªŒè¯
      const state = get()
      if (!state.userCredits) {
        await get().getUserCredits()
      }
      
      // åˆ›å»ºä¼šè¯åŽç«‹å³åˆ·æ–°æ¨¡åž‹åˆ—è¡¨ï¼Œç¡®ä¿æµå¼è®¾ç½®æœ€æ–°
      if (!state.aiModels.length) {
        await get().getAIModels()
      }
      
      const response = await apiClient.post('/chat/conversations', conversationData)
      const newConversation = response.data.data
      
      // åˆå§‹åŒ–æ–°å¯¹è¯çš„çŠ¶æ€
      get().updateConversationState(newConversation.id, { messages: [] })
      
      set(state => ({
        conversations: [newConversation, ...state.conversations],
        currentConversationId: newConversation.id,
        currentConversation: newConversation,
        conversationsLoading: false
      }))
      
      return newConversation
    } catch (error) {
      console.error('åˆ›å»ºä¼šè¯å¤±è´¥:', error)
      set({ conversationsLoading: false })
      throw error
    }
  },
  
  // ðŸ”¥ é€‰æ‹©ä¼šè¯ - ä¼˜åŒ–ä¸ºåªåœ¨éœ€è¦æ—¶åŠ è½½æ¶ˆæ¯
  selectConversation: async (conversationId) => {
    const state = get()
    
    // å¦‚æžœé€‰æ‹©çš„æ˜¯å½“å‰ä¼šè¯ï¼Œè·³è¿‡
    if (state.currentConversationId === conversationId && state.currentConversation) {
      return
    }
    
    // ç«‹å³åˆ‡æ¢åˆ°æ–°å¯¹è¯
    set({ 
      currentConversationId: conversationId
    })
    
    // æ£€æŸ¥æ˜¯å¦å·²æœ‰ç¼“å­˜çš„æ¶ˆæ¯
    const convState = state.getConversationState(conversationId)
    if (convState.messages && convState.messages.length > 0) {
      // å¦‚æžœæœ‰ç¼“å­˜ï¼Œç«‹å³æ˜¾ç¤º
      console.log('ä½¿ç”¨ç¼“å­˜çš„æ¶ˆæ¯')
      
      // èŽ·å–å¯¹è¯è¯¦æƒ…ï¼ˆå¯èƒ½éœ€è¦æ›´æ–°ï¼‰
      try {
        const conversationResponse = await apiClient.get(`/chat/conversations/${conversationId}`)
        set({
          currentConversation: conversationResponse.data.data
        })
      } catch (error) {
        console.error('èŽ·å–ä¼šè¯è¯¦æƒ…å¤±è´¥:', error)
      }
      
      return
    }
    
    // æ²¡æœ‰ç¼“å­˜ï¼Œéœ€è¦åŠ è½½
    set({ messagesLoading: true })
    
    try {
      // å¹¶è¡ŒåŠ è½½ä¼šè¯è¯¦æƒ…å’Œæ¶ˆæ¯
      const [conversationResponse, messagesResponse] = await Promise.all([
        apiClient.get(`/chat/conversations/${conversationId}`),
        apiClient.get(`/chat/conversations/${conversationId}/messages`)
      ])
      
      const conversation = conversationResponse.data.data
      const messages = messagesResponse.data.data
      
      // æ›´æ–°å½“å‰å¯¹è¯å’Œæ¶ˆæ¯
      set({
        currentConversation: conversation,
        messagesLoading: false
      })
      
      // ç¼“å­˜æ¶ˆæ¯åˆ°å¯¹è¯çŠ¶æ€
      get().updateConversationState(conversationId, { messages })
      
      // é€‰æ‹©ä¼šè¯åŽï¼Œå¦‚æžœæ²¡æœ‰æ¨¡åž‹åˆ—è¡¨ï¼ŒåŠ è½½ä¸€æ¬¡
      if (!state.aiModels.length) {
        get().getAIModels()
      }
      
    } catch (error) {
      console.error('èŽ·å–ä¼šè¯å¤±è´¥:', error)
      set({ 
        messagesLoading: false,
        currentConversationId: null,
        currentConversation: null
      })
    }
  },
  
  // å‘é€æ¶ˆæ¯ - é›†æˆç§¯åˆ†æ‰£å‡
  sendMessage: async (content, fileId = null) => {
    const state = get()
    if (!state.currentConversation) return
    
    const conversationId = state.currentConversation.id
    
    // ç¡®ä¿æœ‰æœ€æ–°çš„æ¨¡åž‹åˆ—è¡¨
    if (!state.aiModels.length) {
      await get().getAIModels()
    }
    
    // æ£€æŸ¥æ¨¡åž‹æ˜¯å¦æ”¯æŒæµå¼ - ä¿®å¤åˆ¤æ–­é€»è¾‘
    const model = state.aiModels.find(m => m.name === state.currentConversation.model_name)
    // ðŸ”¥ å…³é”®ä¿®å¤ï¼šå¤„ç†æ•°å­—1å’Œå¸ƒå°”trueçš„æƒ…å†µ
    const useStream = !!(model?.stream_enabled)
    
    // æ·»åŠ è°ƒè¯•æ—¥å¿—
    console.log('å‘é€æ¶ˆæ¯è°ƒè¯•:', {
      currentModel: state.currentConversation.model_name,
      foundModel: model,
      streamEnabled: model?.stream_enabled,
      streamEnabledType: typeof model?.stream_enabled,
      useStream
    })
    
    if (useStream) {
      // ä½¿ç”¨æµå¼å‘é€
      console.log('ä½¿ç”¨æµå¼å‘é€')
      return get().sendStreamMessage(content, fileId)
    }
    
    console.log('ä½¿ç”¨éžæµå¼å‘é€')
    
    // æ›´æ–°å½“å‰å¯¹è¯çš„typingçŠ¶æ€
    get().updateConversationState(conversationId, { typing: true })
    
    // ç¡®ä¿æœ‰ç§¯åˆ†çŠ¶æ€ç”¨äºŽå‘é€å‰éªŒè¯
    if (!state.userCredits) {
      await get().getUserCredits()
    }
    
    // ç«‹å³æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢
    const userMessage = {
      id: `temp-${Date.now()}`,
      role: 'user',
      content,
      created_at: new Date().toISOString(),
      temp: true
    }
    
    // æ›´æ–°æ¶ˆæ¯åˆ°å¯¹è¯çŠ¶æ€
    const currentMessages = get().messages
    get().updateConversationState(conversationId, { 
      messages: [...currentMessages, userMessage] 
    })
    
    // åˆ›å»ºå¯å–æ¶ˆçš„è¯·æ±‚
    const request = apiClient.post(
      `/chat/conversations/${conversationId}/messages`,
      { content, file_id: fileId, stream: false }
    )
    
    // ä¿å­˜è¯·æ±‚å¼•ç”¨
    get().updateConversationState(conversationId, { activeRequest: request })
    
    try {
      const response = await request
      const responseData = response.data.data
      
      // ç§»é™¤ä¸´æ—¶æ¶ˆæ¯ï¼Œæ·»åŠ çœŸå®žçš„ç”¨æˆ·æ¶ˆæ¯å’ŒAIå›žå¤
      const newMessages = [
        ...currentMessages.filter(msg => !msg.temp),
        responseData.user_message,
        responseData.assistant_message
      ]
      
      get().updateConversationState(conversationId, { 
        messages: newMessages,
        typing: false, 
        activeRequest: null 
      })
      
      // ðŸ”¥ æ›´æ–°ç§¯åˆ†çŠ¶æ€ - é™é»˜æ›´æ–°ï¼Œä¸è§¦å‘ç•Œé¢åˆ·æ–°
      if (responseData.credits_info) {
        set(state => ({
          userCredits: state.userCredits ? {
            ...state.userCredits,
            credits_stats: {
              ...state.userCredits.credits_stats,
              remaining: responseData.credits_info.credits_remaining,
              used: state.userCredits.credits_stats.used + responseData.credits_info.credits_consumed
            }
          } : null
        }))
      }
      
      // ðŸ”¥ æ›´æ–°ä¼šè¯ä¿¡æ¯ - åªæ›´æ–°å¯¹è¯åˆ—è¡¨ä¸­çš„ç»Ÿè®¡ï¼Œä¸é‡æ–°åŠ è½½
      if (responseData.conversation) {
        set(state => ({
          currentConversation: responseData.conversation,
          conversations: state.conversations.map(conv => 
            conv.id === responseData.conversation.id 
              ? responseData.conversation 
              : conv
          )
        }))
      }
      
      return responseData
    } catch (error) {
      // ç§»é™¤ä¸´æ—¶æ¶ˆæ¯
      const filteredMessages = currentMessages.filter(msg => !msg.temp)
      get().updateConversationState(conversationId, { 
        messages: filteredMessages,
        typing: false, 
        activeRequest: null 
      })
      
      console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error)
      throw error
    }
  },
  
  // å‘é€æµå¼æ¶ˆæ¯ - é‡å†™å®žçŽ°
  sendStreamMessage: async (content, fileId = null) => {
    const state = get()
    if (!state.currentConversation) return
    
    const conversationId = state.currentConversation.id
    
    console.log('å¼€å§‹æµå¼å‘é€æ¶ˆæ¯')
    
    // æ›´æ–°å½“å‰å¯¹è¯çš„æµå¼çŠ¶æ€
    get().updateConversationState(conversationId, { 
      typing: true, 
      isStreaming: true, 
      streamingContent: '' 
    })
    
    // ç¡®ä¿æœ‰ç§¯åˆ†çŠ¶æ€
    if (!state.userCredits) {
      await get().getUserCredits()
    }
    
    // ç«‹å³æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢ï¼ˆä¸´æ—¶ï¼‰
    const tempUserMessageId = `temp-user-${Date.now()}`
    const tempUserMessage = {
      id: tempUserMessageId,
      role: 'user',
      content,
      created_at: new Date().toISOString(),
      temp: true
    }
    
    // é¢„åˆ›å»ºAIæ¶ˆæ¯å ä½ï¼ˆä¸´æ—¶ï¼‰
    const tempAiMessageId = `temp-ai-${Date.now()}`
    const tempAiMessage = {
      id: tempAiMessageId,
      role: 'assistant',
      content: '',
      created_at: new Date().toISOString(),
      temp: true,
      streaming: true
    }
    
    // æ›´æ–°æ¶ˆæ¯åˆ°å¯¹è¯çŠ¶æ€
    const currentMessages = get().messages
    get().updateConversationState(conversationId, { 
      messages: [...currentMessages, tempUserMessage, tempAiMessage],
      streamingMessageId: tempAiMessageId
    })
    
    try {
      let realUserMessage = null
      let realAiMessageId = null
      let fullContent = ''
      let isCancelled = false
      
      // ä½¿ç”¨æµå¼POSTè¯·æ±‚ - é‡è¦ï¼šè¿™é‡Œè¦ä¼ é€’ stream: true
      await apiClient.postStream(
        `/chat/conversations/${conversationId}/messages`,
        { content, file_id: fileId, stream: true }, // ðŸ”¥ å…³é”®ä¿®æ”¹ï¼šç¡®ä¿ä¼ é€’ stream: true
        {
          onInit: (data) => {
            console.log('æµå¼åˆå§‹åŒ–:', data)
            // èŽ·å–çœŸå®žçš„ç”¨æˆ·æ¶ˆæ¯å’ŒAIæ¶ˆæ¯ID
            realUserMessage = data.user_message
            realAiMessageId = data.ai_message_id
            
            // æ›´æ–°ä¸ºçœŸå®žçš„ç”¨æˆ·æ¶ˆæ¯ï¼Œä¿ç•™AIå ä½æ¶ˆæ¯
            const updatedMessages = get().messages.map(msg => 
              msg.id === tempUserMessageId ? realUserMessage : 
              msg.id === tempAiMessageId ? { ...msg, id: realAiMessageId } : 
              msg
            )
            
            get().updateConversationState(conversationId, { 
              messages: updatedMessages,
              streamingMessageId: realAiMessageId
            })
            
            // æ›´æ–°ç§¯åˆ†ä¿¡æ¯
            if (data.credits_info) {
              set(state => ({
                userCredits: state.userCredits ? {
                  ...state.userCredits,
                  credits_stats: {
                    ...state.userCredits.credits_stats,
                    remaining: data.credits_info.credits_remaining
                  }
                } : null
              }))
            }
          },
          
          onMessage: (data) => {
            // æ£€æŸ¥æ˜¯å¦å·²å–æ¶ˆ
            const currentState = get().getConversationState(conversationId)
            if (!currentState.isStreaming) {
              isCancelled = true
              return
            }
            
            console.log('æ”¶åˆ°æµå¼ç‰‡æ®µ:', data.content)
            // ç´¯åŠ å†…å®¹
            fullContent += data.content || ''
            
            // æ›´æ–°æµå¼å†…å®¹ - å®žæ—¶æ›´æ–°æ¶ˆæ¯å†…å®¹
            const updatedMessages = get().messages.map(msg => 
              msg.id === realAiMessageId
                ? { ...msg, content: fullContent, streaming: true }
                : msg
            )
            
            get().updateConversationState(conversationId, { messages: updatedMessages })
          },
          
          onComplete: (data) => {
            console.log('æµå¼å®Œæˆ:', data)
            
            // å¦‚æžœè¢«å–æ¶ˆäº†ï¼Œæ˜¾ç¤ºéƒ¨åˆ†å†…å®¹
            if (isCancelled || data.cancelled) {
              const finalContent = fullContent || data.content || ''
              
              // åˆ›å»ºæœ€ç»ˆçš„AIæ¶ˆæ¯ï¼ˆè¢«ä¸­æ–­çš„ï¼‰
              const finalAiMessage = {
                id: realAiMessageId,
                role: 'assistant',
                content: finalContent + '\n\n[å·²åœæ­¢ç”Ÿæˆ]',
                tokens: data.tokens || 0,
                created_at: new Date().toISOString(),
                streaming: false
              }
              
              const finalMessages = get().messages.map(msg => 
                msg.id === realAiMessageId
                  ? finalAiMessage
                  : msg
              )
              
              get().updateConversationState(conversationId, {
                messages: finalMessages,
                typing: false,
                isStreaming: false,
                streamingContent: '',
                streamingMessageId: null
              })
            } else {
              // æ­£å¸¸å®Œæˆ
              const finalAiMessage = {
                id: data.messageId || realAiMessageId,
                role: 'assistant',
                content: data.content || fullContent,
                tokens: data.tokens || 0,
                created_at: new Date().toISOString(),
                streaming: false
              }
              
              const finalMessages = get().messages.map(msg => 
                msg.id === realAiMessageId
                  ? finalAiMessage
                  : msg
              )
              
              get().updateConversationState(conversationId, {
                messages: finalMessages,
                typing: false,
                isStreaming: false,
                streamingContent: '',
                streamingMessageId: null
              })
            }
            
            // æ›´æ–°ä¼šè¯ä¿¡æ¯
            if (data.conversationId) {
              // å¯ä»¥é€‰æ‹©æ€§åœ°åˆ·æ–°ä¼šè¯ä¿¡æ¯
              // get().selectConversation(data.conversationId)
            }
          },
          
          onError: (error) => {
            console.error('æµå¼ä¼ è¾“é”™è¯¯:', error)
            
            // ç§»é™¤ä¸´æ—¶æ¶ˆæ¯
            const filteredMessages = get().messages.filter(msg => 
              msg.id !== tempUserMessageId && 
              msg.id !== tempAiMessageId &&
              msg.id !== realAiMessageId
            )
            
            get().updateConversationState(conversationId, {
              messages: filteredMessages,
              typing: false,
              isStreaming: false,
              streamingContent: '',
              streamingMessageId: null
            })
            
            throw error
          }
        }
      )
      
    } catch (error) {
      // æ¸…ç†çŠ¶æ€
      const cleanMessages = get().messages.filter(msg => !msg.temp && !msg.streaming)
      
      get().updateConversationState(conversationId, {
        messages: cleanMessages,
        typing: false,
        isStreaming: false,
        streamingContent: '',
        streamingMessageId: null
      })
      
      console.error('æµå¼æ¶ˆæ¯å‘é€å¤±è´¥:', error)
      throw error
    }
  },
  
  // ðŸ”¥ åœæ­¢ç”Ÿæˆ - æ”¯æŒæµå¼å’Œéžæµå¼
  stopGeneration: () => {
    const state = get()
    const conversationId = state.currentConversationId
    if (!conversationId) return
    
    const convState = state.getConversationState(conversationId)
    
    console.log('åœæ­¢ç”Ÿæˆ', { conversationId, convState })
    
    // å¦‚æžœæ˜¯æµå¼è¯·æ±‚ï¼Œå–æ¶ˆæµå¼
    if (convState.isStreaming) {
      apiClient.cancelStream()
    }
    
    // å¦‚æžœæœ‰æ´»è·ƒçš„éžæµå¼è¯·æ±‚ï¼Œå–æ¶ˆå®ƒ
    if (convState.activeRequest && convState.activeRequest.cancel) {
      convState.activeRequest.cancel()
    }
    
    // æ›´æ–°çŠ¶æ€
    get().updateConversationState(conversationId, {
      isStreaming: false,
      typing: false,
      activeRequest: null
    })
  },
  
  // å…¼å®¹æ—§çš„åœæ­¢æµå¼ä¼ è¾“æ–¹æ³•
  stopStreaming: () => {
    get().stopGeneration()
  },
  
  // æ›´æ–°ä¼šè¯ - æ”¯æŒä¸Šä¸‹æ–‡æ•°é‡å’Œtemperatureæ›´æ–°
  updateConversation: async (conversationId, updateData) => {
    try {
      const response = await apiClient.put(`/chat/conversations/${conversationId}`, updateData)
      const updatedConversation = response.data.data
      
      set(state => ({
        conversations: state.conversations.map(conv =>
          conv.id === conversationId ? updatedConversation : conv
        ),
        currentConversation: state.currentConversationId === conversationId 
          ? updatedConversation 
          : state.currentConversation
      }))
      
      return updatedConversation
    } catch (error) {
      console.error('æ›´æ–°ä¼šè¯å¤±è´¥:', error)
      throw error
    }
  },
  
  // ðŸ”¥ åˆ é™¤ä¼šè¯ - ä¼˜åŒ–çŠ¶æ€ç®¡ç†
  deleteConversation: async (conversationId) => {
    try {
      await apiClient.delete(`/chat/conversations/${conversationId}`)
      
      // æ¸…é™¤è¯¥å¯¹è¯çš„çŠ¶æ€
      const state = get()
      const newStates = new Map(state.conversationStates)
      newStates.delete(conversationId)
      
      set(state => ({
        conversations: state.conversations.filter(conv => conv.id !== conversationId),
        conversationStates: newStates,
        // å¦‚æžœåˆ é™¤çš„æ˜¯å½“å‰ä¼šè¯ï¼Œæ¸…ç©ºå½“å‰ä¼šè¯çŠ¶æ€
        currentConversationId: state.currentConversationId === conversationId ? null : state.currentConversationId,
        currentConversation: state.currentConversationId === conversationId ? null : state.currentConversation
      }))
    } catch (error) {
      console.error('åˆ é™¤ä¼šè¯å¤±è´¥:', error)
      throw error
    }
  },
  
  // èŽ·å–AIæ¨¡åž‹åˆ—è¡¨ - åŒ…å«ç§¯åˆ†ä¿¡æ¯
  getAIModels: async () => {
    try {
      const response = await apiClient.get('/chat/models')
      const models = response.data.data
      
      // æ·»åŠ è°ƒè¯•æ—¥å¿—
      console.log('èŽ·å–åˆ°çš„AIæ¨¡åž‹åˆ—è¡¨:', models)
      
      set({ aiModels: models })
      return models
    } catch (error) {
      console.error('èŽ·å–AIæ¨¡åž‹åˆ—è¡¨å¤±è´¥:', error)
    }
  },

  // æ£€æŸ¥ç§¯åˆ†æ˜¯å¦å……è¶³ - å¦‚æžœæ²¡æœ‰ç§¯åˆ†çŠ¶æ€ï¼Œå…ˆèŽ·å–ä¸€æ¬¡
  checkCreditsForModel: (modelName) => {
    const state = get()
    
    // å¦‚æžœæ²¡æœ‰ç§¯åˆ†çŠ¶æ€ï¼Œå¯èƒ½éœ€è¦èŽ·å–ç§¯åˆ†çŠ¶æ€
    if (!state.userCredits || !state.aiModels.length) {
      // é™é»˜èŽ·å–ä¸€æ¬¡ç§¯åˆ†çŠ¶æ€
      if (!state.creditsLoading) {
        get().getUserCredits().catch(() => {})
      }
      return false
    }
    
    const model = state.aiModels.find(m => m.name === modelName)
    const requiredCredits = model?.credits_per_chat || 10
    
    return state.userCredits.credits_stats.remaining >= requiredCredits
  },

  // èŽ·å–æ¨¡åž‹æ‰€éœ€ç§¯åˆ†
  getModelCredits: (modelName) => {
    const state = get()
    const model = state.aiModels.find(m => m.name === modelName)
    return model?.credits_per_chat || 10
  },
  
  // ðŸ”¥ æ‰‹åŠ¨åˆ·æ–°ä¼šè¯åˆ—è¡¨ - æ–°å¢žæ–¹æ³•
  refreshConversations: async () => {
    return await get().getConversations(true)
  },
  
  // æ¸…é™¤å½“å‰ä¼šè¯
  clearCurrentConversation: () => {
    set({
      currentConversationId: null,
      currentConversation: null
    })
  },
  
  // é‡ç½®store
  reset: () => {
    // å–æ¶ˆæ‰€æœ‰æ´»è·ƒçš„è¯·æ±‚
    get().conversationStates.forEach((state) => {
      if (state.activeRequest && state.activeRequest.cancel) {
        state.activeRequest.cancel()
      }
    })
    
    apiClient.cancelAllRequests()
    
    set({
      conversations: [],
      conversationsLoading: false,
      conversationsLoaded: false,
      currentConversationId: null,
      currentConversation: null,
      messagesLoading: false,
      aiModels: [],
      userCredits: null,
      creditsLoading: false,
      conversationStates: new Map()
    })
  }
}))

export default useChatStore

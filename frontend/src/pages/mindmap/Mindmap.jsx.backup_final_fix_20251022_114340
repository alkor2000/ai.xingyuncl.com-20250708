/**
 * 思维导图工具 - 优化版
 * 修复：代码编辑器大小、Markdown 连线、Mermaid 初始缩放、整体布局
 */
import React, { useState, useRef, useEffect } from 'react';
import { 
  Button, 
  Input, 
  Space, 
  message, 
  Tabs, 
  Tooltip,
  Typography,
  Layout
} from 'antd';
import { 
  SaveOutlined, 
  ZoomInOutlined, 
  ZoomOutOutlined,
  ReloadOutlined,
  ExpandOutlined,
  FileTextOutlined,
  FileImageOutlined,
  FilePdfOutlined
} from '@ant-design/icons';
import { Transformer } from 'markmap-lib';
import { Markmap } from 'markmap-view';
import './Mindmap.less';
import MermaidPreview from './components/MermaidPreview';
import SvgPreview from './components/SvgPreview';
import { MARKDOWN_TEMPLATE, MERMAID_TEMPLATE, SVG_TEMPLATE } from './constants/templates';
import apiClient from '../../utils/api';
import useAuthStore from '../../stores/authStore';

const { TextArea } = Input;
const { Text } = Typography;
const { Sider, Content } = Layout;

const Mindmap = () => {
  const [contentType, setContentType] = useState('markdown');
  const [content, setContent] = useState(MARKDOWN_TEMPLATE);
  const [title, setTitle] = useState('');
  const [isSaving, setIsSaving] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const [creditsConfig, setCreditsConfig] = useState(null);
  const [zoomLevel, setZoomLevel] = useState(0.7); // 默认 70%
  
  const svgRef = useRef(null);
  const markmapRef = useRef(null);
  const previewRef = useRef(null);
  const user = useAuthStore(state => state.user);

  useEffect(() => {
    loadCreditsConfig();
  }, []);

  const loadCreditsConfig = async () => {
    try {
      const response = await apiClient.get('/mindmap/credits-config');
      if (response.data.success) {
        setCreditsConfig(response.data.data);
      }
    } catch (error) {
      console.error('加载积分配置失败:', error);
    }
  };

  const handleTabChange = (key) => {
    setContentType(key);
    setZoomLevel(key === 'markdown' ? 1 : 0.7); // Markdown 100%, 其他 70%
    
    if (key === 'markdown') {
      setContent(MARKDOWN_TEMPLATE);
    } else if (key === 'mermaid') {
      setContent(MERMAID_TEMPLATE);
    } else if (key === 'svg') {
      setContent(SVG_TEMPLATE);
    }
  };

  const renderMarkdownPreview = () => {
    if (!svgRef.current || !content) return;

    try {
      const transformer = new Transformer();
      const { root } = transformer.transform(content);
      svgRef.current.innerHTML = '';

      const options = {
        color: (node) => {
          const colors = ['#1677ff', '#52c41a', '#faad14', '#f5222d', '#722ed1', '#13c2c2'];
          return colors[node.depth % colors.length];
        },
        duration: 500,
        nodeMinHeight: 16,
        paddingX: 8,
        spacingVertical: 10,
        spacingHorizontal: 80,
        autoFit: true,
        initialExpandLevel: -1,
        zoom: true,
        pan: true
      };

      const mm = Markmap.create(svgRef.current, options, root);
      markmapRef.current = mm;

      setTimeout(() => {
        mm.fit();
      }, 300);
    } catch (error) {
      console.error('Markmap 渲染失败:', error);
      message.error('思维导图渲染失败');
    }
  };

  useEffect(() => {
    if (contentType === 'markdown') {
      renderMarkdownPreview();
    }
  }, [content, contentType]);

  const handleZoom = (type) => {
    if (contentType === 'markdown') {
      if (!markmapRef.current) return;
      try {
        if (type === 'in') markmapRef.current.rescale(1.25);
        else if (type === 'out') markmapRef.current.rescale(0.8);
        else if (type === 'fit') markmapRef.current.fit();
      } catch (error) {
        console.error('缩放失败:', error);
      }
    } else {
      setZoomLevel(prev => {
        if (type === 'in') return Math.min(prev * 1.2, 3);
        if (type === 'out') return Math.max(prev / 1.2, 0.3);
        if (type === 'fit') return 0.7;
        return prev;
      });
    }
  };

  const handleExpandAll = () => {
    if (contentType !== 'markdown' || !markmapRef.current) return;
    try {
      const mm = markmapRef.current;
      const expandNode = (node) => {
        if (node.payload) node.payload.fold = 0;
        if (node.children) node.children.forEach(child => expandNode(child));
      };
      if (mm.state?.data) {
        expandNode(mm.state.data);
        mm.setData(mm.state.data);
        mm.fit();
      }
    } catch (error) {
      console.error('展开失败:', error);
    }
  };

  const handleSave = async () => {
    if (!title.trim()) return message.warning('请输入标题');
    if (!content.trim()) return message.warning('请输入内容');

    if (creditsConfig?.save_credits > 0) {
      if (!user || (user.credits_quota - user.used_credits) < creditsConfig.save_credits) {
        return message.error(`积分不足，需要 ${creditsConfig.save_credits} 积分`);
      }
    }

    setIsSaving(true);
    try {
      const response = await apiClient.post('/mindmap', {
        title: title.trim(),
        content: content.trim(),
        content_type: contentType
      });
      if (response.data.success) {
        message.success(response.data.message || '保存成功');
        await useAuthStore.getState().getCurrentUser();
      }
    } catch (error) {
      message.error(error.response?.data?.message || '保存失败');
    } finally {
      setIsSaving(false);
    }
  };

  const handleExport = async (format) => {
    if (!content.trim()) return message.warning('请先创建内容');

    const creditsMap = {
      svg: creditsConfig?.export_svg_credits || 0,
      png: creditsConfig?.export_png_credits || 0,
      pdf: creditsConfig?.export_pdf_credits || 0,
      markdown: creditsConfig?.export_markdown_credits || 0
    };

    const required = creditsMap[format];
    if (required > 0 && (!user || (user.credits_quota - user.used_credits) < required)) {
      return message.error(`积分不足，需要 ${required} 积分`);
    }

    setIsExporting(true);
    try {
      if (format === 'svg') await exportSVG();
      else if (format === 'png') await exportPNG();
      else if (format === 'pdf') await exportPDF();
      else if (format === 'markdown') await exportMarkdown();

      await apiClient.post('/mindmap/export-log', { type: format });
      await useAuthStore.getState().getCurrentUser();
      message.success('导出成功');
    } catch (error) {
      message.error(error.response?.data?.message || '导出失败');
    } finally {
      setIsExporting(false);
    }
  };

  const getSVGElement = () => {
    if (contentType === 'markdown') return svgRef.current?.querySelector('svg');
    if (contentType === 'mermaid') return previewRef.current?.querySelector('svg');
    if (contentType === 'svg') {
      const div = document.createElement('div');
      div.innerHTML = content;
      return div.querySelector('svg');
    }
  };

  const exportSVG = async () => {
    const svg = getSVGElement();
    if (!svg) throw new Error('未找到 SVG 元素');
    const data = new XMLSerializer().serializeToString(svg);
    const blob = new Blob([data], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${title || 'mindmap'}.svg`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const exportPNG = async () => {
    const svg = getSVGElement();
    if (!svg) throw new Error('未找到 SVG 元素');
    const data = new XMLSerializer().serializeToString(svg);
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();

    return new Promise((resolve, reject) => {
      img.onload = () => {
        canvas.width = img.width * 2;
        canvas.height = img.height * 2;
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        canvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `${title || 'mindmap'}.png`;
          link.click();
          URL.revokeObjectURL(url);
          resolve();
        }, 'image/png');
      };
      img.onerror = reject;
      img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(data)));
    });
  };

  const exportPDF = async () => {
    const { jsPDF } = await import('jspdf');
    await import('svg2pdf.js');
    const svg = getSVGElement();
    if (!svg) throw new Error('未找到 SVG 元素');
    const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
    await pdf.svg(svg, {
      x: 0, y: 0,
      width: pdf.internal.pageSize.getWidth(),
      height: pdf.internal.pageSize.getHeight()
    });
    pdf.save(`${title || 'mindmap'}.pdf`);
  };

  const exportMarkdown = async () => {
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${title || 'mindmap'}.md`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const renderPreviewContent = () => {
    if (contentType === 'markdown') {
      return (
        <div className="mindmap-svg" ref={previewRef}>
          <svg ref={svgRef}></svg>
        </div>
      );
    }

    return (
      <div style={{ 
        transform: `scale(${zoomLevel})`,
        transformOrigin: 'top left',
        transition: 'transform 0.3s ease',
        padding: '20px',
        background: '#fff',
        borderRadius: '12px',
        boxShadow: '0 4px 24px rgba(0, 0, 0, 0.08)',
        width: 'max-content',
        maxWidth: '1400px'
      }} ref={previewRef}>
        {contentType === 'mermaid' ? <MermaidPreview code={content} /> : <SvgPreview code={content} />}
      </div>
    );
  };

  const renderCreditsInfo = () => {
    if (!creditsConfig) return null;
    const current = user ? (user.credits_quota - user.used_credits) : 0;
    return (
      <Space direction="vertical" size={4} style={{ fontSize: '12px' }}>
        <Text type="secondary">余额: {current}分 {creditsConfig.save_credits > 0 && `(保存: ${creditsConfig.save_credits}分)`}</Text>
        <Space size={8}>
          {creditsConfig.export_svg_credits > 0 && <Text type="secondary">SVG: {creditsConfig.export_svg_credits}分</Text>}
          {creditsConfig.export_png_credits > 0 && <Text type="secondary">PNG: {creditsConfig.export_png_credits}分</Text>}
          {creditsConfig.export_pdf_credits > 0 && <Text type="secondary">PDF: {creditsConfig.export_pdf_credits}分</Text>}
          {creditsConfig.export_markdown_credits > 0 && <Text type="secondary">MD: {creditsConfig.export_markdown_credits}分</Text>}
        </Space>
      </Space>
    );
  };

  return (
    <div className="mindmap-page-container">
      <div className="mindmap-page-header">
        <div className="page-header-left">
          <Input placeholder="输入标题" value={title} onChange={(e) => setTitle(e.target.value)} style={{ width: 300 }} />
        </div>
        <div className="page-header-actions">
          <Space size={16}>
            <Button type="primary" icon={<SaveOutlined />} onClick={handleSave} loading={isSaving}>保存</Button>
            <Button.Group>
              <Tooltip title={`SVG ${creditsConfig?.export_svg_credits > 0 ? `(${creditsConfig.export_svg_credits}分)` : ''}`}>
                <Button icon={<FileImageOutlined />} onClick={() => handleExport('svg')} loading={isExporting}>导出</Button>
              </Tooltip>
              <Tooltip title={`PNG ${creditsConfig?.export_png_credits > 0 ? `(${creditsConfig.export_png_credits}分)` : ''}`}>
                <Button icon={<FileImageOutlined />} onClick={() => handleExport('png')} loading={isExporting} />
              </Tooltip>
              <Tooltip title={`PDF ${creditsConfig?.export_pdf_credits > 0 ? `(${creditsConfig.export_pdf_credits}分)` : ''}`}>
                <Button icon={<FilePdfOutlined />} onClick={() => handleExport('pdf')} loading={isExporting} />
              </Tooltip>
              <Tooltip title={`Markdown ${creditsConfig?.export_markdown_credits > 0 ? `(${creditsConfig.export_markdown_credits}分)` : ''}`}>
                <Button icon={<FileTextOutlined />} onClick={() => handleExport('markdown')} loading={isExporting} />
              </Tooltip>
            </Button.Group>
            {renderCreditsInfo()}
          </Space>
        </div>
      </div>

      <div className="mindmap-tabs-container">
        <Tabs activeKey={contentType} onChange={handleTabChange} items={[
          { key: 'markdown', label: '思维导图 (Markdown)', icon: <FileTextOutlined /> },
          { key: 'mermaid', label: '流程图 (Mermaid)', icon: <FileImageOutlined /> },
          { key: 'svg', label: '矢量图 (SVG)', icon: <FileImageOutlined /> }
        ]} />
      </div>

      <Layout className="mindmap-main-layout">
        <Sider className="mindmap-editor-sider">
          <div className="editor-header">
            <Text strong>代码编辑器</Text>
          </div>
          <div className="editor-wrapper">
            <TextArea
              value={content}
              onChange={(e) => setContent(e.target.value)}
              placeholder={`请输入 ${contentType === 'markdown' ? 'Markdown' : contentType === 'mermaid' ? 'Mermaid' : 'SVG'} 代码...`}
            />
          </div>
        </Sider>

        <Content className="mindmap-preview-content">
          <div className="mindmap-toolbar">
            <Space size={8}>
              <Text strong>实时预览</Text>
              <div className="toolbar-divider" />
              <Tooltip title="放大"><button className="zoom-button" onClick={() => handleZoom('in')}><ZoomInOutlined /></button></Tooltip>
              <Tooltip title="缩小"><button className="zoom-button" onClick={() => handleZoom('out')}><ZoomOutOutlined /></button></Tooltip>
              <Tooltip title="自适应"><button className="zoom-button" onClick={() => handleZoom('fit')}><ReloadOutlined /></button></Tooltip>
              {contentType === 'markdown' && (
                <Tooltip title="展开所有"><button className="zoom-button" onClick={handleExpandAll}><ExpandOutlined /></button></Tooltip>
              )}
              {contentType !== 'markdown' && <Text type="secondary" style={{ fontSize: '12px', marginLeft: '8px' }}>{Math.round(zoomLevel * 100)}%</Text>}
            </Space>
          </div>
          <div className="mindmap-canvas">
            {renderPreviewContent()}
          </div>
        </Content>
      </Layout>
    </div>
  );
};

export default Mindmap;

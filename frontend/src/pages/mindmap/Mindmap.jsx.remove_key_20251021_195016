/**
 * 思维导图编辑器页面 - 多模式支持版本
 * 支持 Markdown、Mermaid、SVG 三种模式
 */

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  Layout, 
  Button, 
  Space, 
  message, 
  Dropdown, 
  Modal,
  Tabs,
  Tooltip,
  Typography,
  Spin,
  Badge
} from 'antd';
import {
  SaveOutlined,
  DownloadOutlined,
  ClearOutlined,
  FullscreenOutlined,
  FullscreenExitOutlined,
  CopyOutlined,
  FileImageOutlined,
  FileOutlined,
  ZoomInOutlined,
  ZoomOutOutlined,
  ReloadOutlined,
  FolderOpenOutlined,
  QuestionCircleOutlined,
  ExpandOutlined,
  DollarOutlined,
  FileTextOutlined,
  FilePdfOutlined
} from '@ant-design/icons';
import Editor from '@monaco-editor/react';
import { Markmap } from 'markmap-view';
import { Transformer } from 'markmap-lib';
import html2canvas from 'html2canvas';
import { jsPDF } from 'jspdf';
import apiClient from '../../utils/api';
import useAuthStore from '../../stores/authStore';
import { MermaidPreview, SvgPreview } from './components';
import TEMPLATES from './constants/templates';
import './Mindmap.less';

const { Header, Sider, Content } = Layout;
const { Title, Text } = Typography;

const MindmapPage = () => {
  // 核心状态
  const [contentType, setContentType] = useState('markdown'); // markdown, mermaid, svg
  const [content, setContent] = useState(TEMPLATES.markdown);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [savedMaps, setSavedMaps] = useState([]);
  const [editorLoading, setEditorLoading] = useState(true);
  const [svgLoading, setSvgLoading] = useState(false);
  const [editorHeight, setEditorHeight] = useState('600px');
  const [creditsConfig, setCreditsConfig] = useState(null);
  const [userCredits, setUserCredits] = useState(0);
  const [renderKey, setRenderKey] = useState(0); // 用于强制重新渲染
  
  // Refs
  const svgRef = useRef(null);
  const markmapRef = useRef(null);
  const transformerRef = useRef(null);
  const containerRef = useRef(null);
  const svgContainerRef = useRef(null);
  const editorWrapperRef = useRef(null);
  const previewRef = useRef(null); // 用于PNG/PDF导出
  const renderTimerRef = useRef(null);
  
  const { user } = useAuthStore();

  // 初始化
  useEffect(() => {
    transformerRef.current = new Transformer();
    
    // 加载本地保存的脑图
    const saved = localStorage.getItem('mindmap_saved');
    if (saved) {
      try {
        setSavedMaps(JSON.parse(saved));
      } catch (e) {
        console.error('加载保存的脑图失败:', e);
      }
    }

    // 获取积分配置
    fetchCreditsConfig();
    
    // 获取用户积分余额
    if (user) {
      setUserCredits(user.credits_stats?.remaining || 0);
    }

    const calculateHeight = () => {
      const windowHeight = window.innerHeight;
      const calculatedHeight = windowHeight - 220;
      setEditorHeight(`${Math.max(400, calculatedHeight)}px`);
    };

    calculateHeight();
    window.addEventListener('resize', calculateHeight);

    return () => {
      window.removeEventListener('resize', calculateHeight);
      if (renderTimerRef.current) {
        clearTimeout(renderTimerRef.current);
      }
      // 清理 Markmap 实例
      if (markmapRef.current) {
        markmapRef.current.destroy();
        markmapRef.current = null;
      }
    };
  }, [user]);

  // 获取积分配置
  const fetchCreditsConfig = async () => {
    try {
      const response = await apiClient.get('/mindmap/credits-config');
      if (response.data.success) {
        setCreditsConfig(response.data.data);
      }
    } catch (error) {
      console.error('获取积分配置失败:', error);
    }
  };

  // 获取用户最新积分
  const fetchUserCredits = async () => {
    try {
      const response = await apiClient.get(`/admin/users/${user.id}/credits`);
      if (response.data.success) {
        const creditsData = response.data.data;
        setUserCredits(creditsData.remaining || 0);
      }
    } catch (error) {
      console.error('获取用户积分失败:', error);
    }
  };

  // 检查积分是否充足
  const checkCredits = async (operation) => {
    try {
      const response = await apiClient.get('/mindmap/check-credits', {
        params: { operation }
      });
      if (response.data.success) {
        return response.data.data;
      }
    } catch (error) {
      console.error('检查积分失败:', error);
      return { sufficient: false, message: '检查积分失败' };
    }
  };

  // 切换内容类型
  const handleTabChange = (key) => {
    console.log('切换到模式:', key);
    
    // 清理旧的渲染定时器
    if (renderTimerRef.current) {
      clearTimeout(renderTimerRef.current);
      renderTimerRef.current = null;
    }
    
    // 如果从 Markdown 切换走，销毁 Markmap 实例
    if (contentType === 'markdown' && markmapRef.current) {
      markmapRef.current.destroy();
      markmapRef.current = null;
      if (svgRef.current) {
        svgRef.current.innerHTML = '';
      }
    }
    
    setContentType(key);
    setContent(TEMPLATES[key]);
    setRenderKey(prev => prev + 1); // 强制重新渲染
    
    // 如果切换到 Markdown，延迟渲染
    if (key === 'markdown') {
      setSvgLoading(true);
      renderTimerRef.current = setTimeout(() => {
        setSvgLoading(false);
        // 再次延迟确保容器已渲染
        setTimeout(() => {
          renderMarkdownMindmap();
        }, 100);
      }, 300);
    }
  };

  // 渲染 Markdown 思维导图
  const renderMarkdownMindmap = useCallback(() => {
    if (contentType !== 'markdown') {
      return;
    }

    if (!svgRef.current || !transformerRef.current) {
      console.log('SVG ref 或 transformer 未就绪');
      return;
    }

    const container = svgContainerRef.current;
    if (!container) {
      console.log('容器未找到');
      return;
    }

    // 等待容器完全渲染
    setTimeout(() => {
      const rect = container.getBoundingClientRect();
      
      // 检查容器尺寸是否有效
      if (!rect || rect.width === 0 || rect.height === 0) {
        console.log('容器尺寸无效，重试...', rect);
        setTimeout(() => renderMarkdownMindmap(), 200);
        return;
      }

      try {
        console.log('开始渲染 Markdown 思维导图，容器尺寸:', rect.width, 'x', rect.height);
        
        // 转换 Markdown
        const { root } = transformerRef.current.transform(content);
        
        // 销毁旧实例
        if (markmapRef.current) {
          markmapRef.current.destroy();
          markmapRef.current = null;
        }

        // 清空容器
        if (svgRef.current) {
          svgRef.current.innerHTML = '';
          
          // 设置 SVG 尺寸
          const svgWidth = Math.max(rect.width - 40, 400);
          const svgHeight = Math.max(rect.height - 40, 300);
          
          svgRef.current.setAttribute('width', svgWidth);
          svgRef.current.setAttribute('height', svgHeight);
          
          console.log('SVG 尺寸设置:', svgWidth, 'x', svgHeight);
        }
        
        // Markmap 配置
        const options = {
          duration: 300,
          nodeFont: '300 16px -apple-system, BlinkMacSystemFont, sans-serif',
          lineHeight: 1.5,
          paddingX: 8,
          autoFit: true,
          color: (node) => {
            const colors = ['#007AFF', '#5856D6', '#FF3B30', '#FF9500', '#34C759', '#00C7BE'];
            const depth = node.state?.depth || 0;
            return colors[depth % colors.length];
          },
          nodeMinHeight: 24,
          spacingVertical: 10,
          spacingHorizontal: 80,
          initialExpandLevel: 2
        };

        // 创建新实例
        markmapRef.current = Markmap.create(svgRef.current, options, root);

        // 延迟自适应
        setTimeout(() => {
          if (markmapRef.current) {
            try {
              markmapRef.current.fit();
              console.log('Markmap 渲染成功');
            } catch (fitError) {
              console.error('Fit 失败:', fitError);
            }
          }
        }, 100);
        
      } catch (error) {
        console.error('渲染思维导图失败:', error);
        message.error('渲染失败: ' + error.message);
      }
    }, 50);
  }, [content, contentType]);

  // 监听 markdown 内容变化
  useEffect(() => {
    if (contentType !== 'markdown' || svgLoading) {
      return;
    }
    
    if (renderTimerRef.current) {
      clearTimeout(renderTimerRef.current);
    }
    
    renderTimerRef.current = setTimeout(() => {
      renderMarkdownMindmap();
    }, 500);
    
    return () => {
      if (renderTimerRef.current) {
        clearTimeout(renderTimerRef.current);
      }
    };
  }, [content, contentType, renderMarkdownMindmap, svgLoading]);

  // 编辑器挂载完成
  const handleEditorDidMount = (editor, monaco) => {
    setEditorLoading(false);
    
    editor.updateOptions({
      fontSize: 14,
      fontFamily: 'SF Mono, Monaco, Consolas, monospace',
      lineHeight: 22,
      renderWhitespace: 'none'
    });

    editor.focus();
    
    setTimeout(() => {
      editor.layout();
    }, 100);
  };

  // 保存到服务器（扣减积分）
  const handleSave = async () => {
    const title = prompt('请输入脑图名称：', `${contentType}_${new Date().toLocaleDateString()}`);
    if (!title) return;

    const credits = await checkCredits('save');
    if (!credits.sufficient) {
      Modal.error({
        title: '积分不足',
        content: `保存思维导图需要${credits.requiredCredits}积分，当前余额${credits.currentCredits}积分`
      });
      return;
    }

    if (credits.requiredCredits > 0) {
      Modal.confirm({
        title: '确认保存',
        content: `保存思维导图将消耗${credits.requiredCredits}积分，当前余额${credits.currentCredits}积分`,
        okText: '确认',
        cancelText: '取消',
        onOk: async () => {
          await saveToServer(title);
        }
      });
    } else {
      await saveToServer(title);
    }
  };

  // 实际保存到服务器
  const saveToServer = async (title) => {
    try {
      const response = await apiClient.post('/mindmap', {
        title,
        content,
        content_type: contentType
      });
      
      if (response.data.success) {
        message.success(response.data.data.message || '保存成功');
        
        const newMap = {
          id: response.data.data.id || Date.now(),
          title,
          content,
          content_type: contentType,
          createdAt: new Date().toISOString()
        };
        
        const updated = [...savedMaps, newMap];
        setSavedMaps(updated);
        localStorage.setItem('mindmap_saved', JSON.stringify(updated));
        
        fetchUserCredits();
      }
    } catch (error) {
      console.error('保存失败:', error);
      message.error(error.response?.data?.message || '保存失败');
    }
  };

  // 加载已保存的脑图
  const handleLoad = (map) => {
    const newType = map.content_type || 'markdown';
    setContent(map.content);
    
    if (newType !== contentType) {
      setContentType(newType);
      setRenderKey(prev => prev + 1); // 强制重新渲染
      if (newType === 'markdown') {
        setSvgLoading(true);
        setTimeout(() => {
          setSvgLoading(false);
          setTimeout(() => renderMarkdownMindmap(), 100);
        }, 300);
      }
    }
    
    message.success(`已加载: ${map.title}`);
  };

  // 删除保存的脑图
  const handleDelete = (id) => {
    const updated = savedMaps.filter(m => m.id !== id);
    setSavedMaps(updated);
    localStorage.setItem('mindmap_saved', JSON.stringify(updated));
    message.success('删除成功');
  };

  // 导出SVG
  const exportSVG = async () => {
    const credits = await checkCredits('export_svg');
    if (!credits.sufficient) {
      Modal.error({
        title: '积分不足',
        content: `导出SVG需要${credits.requiredCredits}积分，当前余额${credits.currentCredits}积分`
      });
      return;
    }

    if (credits.requiredCredits > 0) {
      Modal.confirm({
        title: '确认导出',
        content: `导出SVG将消耗${credits.requiredCredits}积分，当前余额${credits.currentCredits}积分`,
        okText: '确认',
        cancelText: '取消',
        onOk: async () => {
          await doExportSVG();
        }
      });
    } else {
      await doExportSVG();
    }
  };

  const doExportSVG = async () => {
    try {
      const response = await apiClient.post('/mindmap/export-log', { type: 'svg' });
      
      if (response.data.success) {
        let svgElement;
        
        if (contentType === 'markdown' && svgRef.current) {
          svgElement = svgRef.current.cloneNode(true);
        } else if (previewRef.current) {
          svgElement = previewRef.current.querySelector('svg')?.cloneNode(true);
        }
        
        if (!svgElement) {
          message.error('未找到可导出的SVG元素');
          return;
        }
        
        const svgData = new XMLSerializer().serializeToString(svgElement);
        const blob = new Blob([svgData], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${contentType}_${Date.now()}.svg`;
        a.click();
        URL.revokeObjectURL(url);
        
        message.success(response.data.data.message || 'SVG导出成功');
        fetchUserCredits();
      }
    } catch (error) {
      console.error('导出失败:', error);
      message.error(error.response?.data?.message || '导出失败');
    }
  };

  // 导出Markdown
  const exportMarkdown = async () => {
    const credits = await checkCredits('export_markdown');
    if (!credits.sufficient) {
      Modal.error({
        title: '积分不足',
        content: `导出Markdown需要${credits.requiredCredits}积分，当前余额${credits.currentCredits}积分`
      });
      return;
    }

    if (credits.requiredCredits > 0) {
      Modal.confirm({
        title: '确认导出',
        content: `导出Markdown将消耗${credits.requiredCredits}积分，当前余额${credits.currentCredits}积分`,
        okText: '确认',
        cancelText: '取消',
        onOk: async () => {
          await doExportMarkdown();
        }
      });
    } else {
      await doExportMarkdown();
    }
  };

  const doExportMarkdown = async () => {
    try {
      const response = await apiClient.post('/mindmap/export-log', { type: 'markdown' });
      
      if (response.data.success) {
        const blob = new Blob([content], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${contentType}_${Date.now()}.md`;
        a.click();
        URL.revokeObjectURL(url);
        
        message.success(response.data.data.message || 'Markdown导出成功');
        fetchUserCredits();
      }
    } catch (error) {
      console.error('导出失败:', error);
      message.error(error.response?.data?.message || '导出失败');
    }
  };

  // 导出PNG
  const exportPNG = async () => {
    const credits = await checkCredits('export_png');
    if (!credits.sufficient) {
      Modal.error({
        title: '积分不足',
        content: `导出PNG需要${credits.requiredCredits}积分，当前余额${credits.currentCredits}积分`
      });
      return;
    }

    if (credits.requiredCredits > 0) {
      Modal.confirm({
        title: '确认导出',
        content: `导出PNG将消耗${credits.requiredCredits}积分，当前余额${credits.currentCredits}积分`,
        okText: '确认',
        cancelText: '取消',
        onOk: async () => {
          await doExportPNG();
        }
      });
    } else {
      await doExportPNG();
    }
  };

  const doExportPNG = async () => {
    try {
      const response = await apiClient.post('/mindmap/export-log', { type: 'png' });
      
      if (response.data.success) {
        const element = previewRef.current || svgContainerRef.current;
        
        if (!element) {
          message.error('未找到可导出的元素');
          return;
        }
        
        const canvas = await html2canvas(element, {
          backgroundColor: '#ffffff',
          scale: 2,
          logging: false
        });
        
        canvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${contentType}_${Date.now()}.png`;
          a.click();
          URL.revokeObjectURL(url);
        });
        
        message.success(response.data.data.message || 'PNG导出成功');
        fetchUserCredits();
      }
    } catch (error) {
      console.error('导出失败:', error);
      message.error(error.response?.data?.message || '导出失败');
    }
  };

  // 导出PDF
  const exportPDF = async () => {
    const credits = await checkCredits('export_pdf');
    if (!credits.sufficient) {
      Modal.error({
        title: '积分不足',
        content: `导出PDF需要${credits.requiredCredits}积分，当前余额${credits.currentCredits}积分`
      });
      return;
    }

    if (credits.requiredCredits > 0) {
      Modal.confirm({
        title: '确认导出',
        content: `导出PDF将消耗${credits.requiredCredits}积分，当前余额${credits.currentCredits}积分`,
        okText: '确认',
        cancelText: '取消',
        onOk: async () => {
          await doExportPDF();
        }
      });
    } else {
      await doExportPDF();
    }
  };

  const doExportPDF = async () => {
    try {
      const response = await apiClient.post('/mindmap/export-log', { type: 'pdf' });
      
      if (response.data.success) {
        const element = previewRef.current || svgContainerRef.current;
        
        if (!element) {
          message.error('未找到可导出的元素');
          return;
        }
        
        const canvas = await html2canvas(element, {
          backgroundColor: '#ffffff',
          scale: 2,
          logging: false
        });
        
        const imgData = canvas.toDataURL('image/png');
        const pdf = new jsPDF({
          orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
          unit: 'px',
          format: [canvas.width, canvas.height]
        });
        
        pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
        pdf.save(`${contentType}_${Date.now()}.pdf`);
        
        message.success(response.data.data.message || 'PDF导出成功');
        fetchUserCredits();
      }
    } catch (error) {
      console.error('导出失败:', error);
      message.error(error.response?.data?.message || '导出失败');
    }
  };

  const copyToClipboard = () => {
    navigator.clipboard.writeText(content).then(() => {
      message.success('已复制到剪贴板');
    }).catch(() => {
      message.error('复制失败');
    });
  };

  const clearContent = () => {
    Modal.confirm({
      title: '确认清空',
      content: '确定要清空所有内容吗？此操作不可恢复。',
      okText: '确定',
      cancelText: '取消',
      onOk: () => {
        setContent('');
        message.success('已清空');
      }
    });
  };

  const handleZoom = (type) => {
    if (contentType !== 'markdown' || !markmapRef.current) return;
    
    try {
      if (type === 'in') {
        markmapRef.current.rescale(1.25);
      } else if (type === 'out') {
        markmapRef.current.rescale(0.8);
      } else if (type === 'fit') {
        markmapRef.current.fit();
      }
    } catch (error) {
      console.error('缩放失败:', error);
    }
  };

  const handleExpandAll = () => {
    if (contentType !== 'markdown' || !markmapRef.current) {
      message.warning('该功能仅支持Markdown模式');
      return;
    }
    
    try {
      const mm = markmapRef.current;
      
      const expandNode = (node) => {
        if (node.payload) {
          node.payload.fold = false;
        }
        if (node.children && node.children.length > 0) {
          node.children.forEach(child => expandNode(child));
        }
      };
      
      if (mm.state && mm.state.data) {
        expandNode(mm.state.data);
        mm.setData(mm.state.data);
        mm.fit();
        message.success('已展开所有节点');
      }
    } catch (error) {
      console.error('展开节点失败:', error);
      message.error('展开失败，请重试');
    }
  };

  const toggleFullscreen = () => {
    if (!isFullscreen) {
      if (containerRef.current?.requestFullscreen) {
        containerRef.current.requestFullscreen();
        setIsFullscreen(true);
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
        setIsFullscreen(false);
      }
    }
  };

  // 导出菜单
  const exportMenuItems = [
    { 
      key: 'svg', 
      label: (
        <Space>
          <FileImageOutlined />
          <span>SVG矢量图</span>
          {creditsConfig && creditsConfig.export_svg_credits > 0 && (
            <Badge count={`${creditsConfig.export_svg_credits}积分`} style={{ backgroundColor: '#52c41a' }} />
          )}
        </Space>
      ),
      onClick: exportSVG 
    },
    { 
      key: 'png', 
      label: (
        <Space>
          <FileImageOutlined />
          <span>PNG图片</span>
          {creditsConfig && creditsConfig.export_png_credits > 0 && (
            <Badge count={`${creditsConfig.export_png_credits}积分`} style={{ backgroundColor: '#52c41a' }} />
          )}
        </Space>
      ),
      onClick: exportPNG 
    },
    { 
      key: 'pdf', 
      label: (
        <Space>
          <FilePdfOutlined />
          <span>PDF文档</span>
          {creditsConfig && creditsConfig.export_pdf_credits > 0 && (
            <Badge count={`${creditsConfig.export_pdf_credits}积分`} style={{ backgroundColor: '#52c41a' }} />
          )}
        </Space>
      ),
      onClick: exportPDF 
    },
    { 
      key: 'markdown', 
      label: (
        <Space>
          <FileTextOutlined />
          <span>源代码</span>
          {creditsConfig && creditsConfig.export_markdown_credits > 0 && (
            <Badge count={`${creditsConfig.export_markdown_credits}积分`} style={{ backgroundColor: '#52c41a' }} />
          )}
        </Space>
      ),
      onClick: exportMarkdown 
    }
  ];

  // 已保存的脑图菜单
  const savedMenuItems = savedMaps.map(map => ({
    key: map.id,
    label: (
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%' }}>
        <span onClick={() => handleLoad(map)} style={{ flex: 1 }}>
          [{map.content_type || 'markdown'}] {map.title}
        </span>
        <Button
          type="text"
          size="small"
          danger
          onClick={(e) => {
            e.stopPropagation();
            handleDelete(map.id);
          }}
        >
          删除
        </Button>
      </div>
    )
  }));

  // Tab项配置
  const tabItems = [
    {
      key: 'markdown',
      label: '思维导图 (Markdown)',
      icon: <FileTextOutlined />
    },
    {
      key: 'mermaid',
      label: '流程图 (Mermaid)',
      icon: <FileImageOutlined />
    },
    {
      key: 'svg',
      label: '矢量图 (SVG)',
      icon: <FileImageOutlined />
    }
  ];

  // 获取编辑器语言
  const getEditorLanguage = () => {
    switch(contentType) {
      case 'markdown': return 'markdown';
      case 'mermaid': return 'markdown';
      case 'svg': return 'xml';
      default: return 'markdown';
    }
  };

  // 渲染预览区域
  const renderPreview = () => {
    if (contentType === 'markdown') {
      return (
        <div className="mindmap-canvas" ref={svgContainerRef}>
          {svgLoading ? (
            <div className="svg-loading">
              <Spin tip="初始化思维导图..." />
            </div>
          ) : (
            <svg ref={svgRef} className="mindmap-svg" />
          )}
        </div>
      );
    } else if (contentType === 'mermaid') {
      return (
        <div className="mindmap-canvas" ref={previewRef}>
          <MermaidPreview 
            key={`mermaid-${renderKey}`}
            code={content} 
          />
        </div>
      );
    } else if (contentType === 'svg') {
      return (
        <div className="mindmap-canvas" ref={previewRef}>
          <SvgPreview 
            key={`svg-${renderKey}`}
            code={content} 
          />
        </div>
      );
    }
  };

  return (
    <div className="mindmap-page-container" ref={containerRef}>
      {/* 页面级工具栏 */}
      <div className="mindmap-page-header">
        <div className="page-header-left">
          <Space>
            <Text type="secondary">
              <DollarOutlined /> 积分余额: {userCredits}
            </Text>
            {creditsConfig && (
              <Text type="secondary" style={{ fontSize: 12 }}>
                (保存: {creditsConfig.save_credits}积分 | 
                SVG: {creditsConfig.export_svg_credits}积分 | 
                PNG: {creditsConfig.export_png_credits}积分 | 
                PDF: {creditsConfig.export_pdf_credits}积分)
              </Text>
            )}
          </Space>
        </div>
        
        <Space className="page-header-actions" size={12}>
          <Button 
            type="primary"
            icon={<SaveOutlined />} 
            onClick={handleSave}
          >
            保存
            {creditsConfig && creditsConfig.save_credits > 0 && (
              <Badge 
                count={creditsConfig.save_credits} 
                style={{ backgroundColor: '#52c41a', marginLeft: 8 }} 
              />
            )}
          </Button>
          
          {savedMaps.length > 0 && (
            <Dropdown menu={{ items: savedMenuItems }} placement="bottomRight">
              <Button icon={<FolderOpenOutlined />}>
                历史 ({savedMaps.length})
              </Button>
            </Dropdown>
          )}
          
          <Dropdown menu={{ items: exportMenuItems }} placement="bottomRight">
            <Button icon={<DownloadOutlined />}>
              导出
            </Button>
          </Dropdown>
          
          <Button 
            icon={<CopyOutlined />} 
            onClick={copyToClipboard}
          >
            复制
          </Button>
          
          <Button 
            danger
            icon={<ClearOutlined />} 
            onClick={clearContent}
          >
            清空
          </Button>
          
          <Button 
            icon={isFullscreen ? <FullscreenExitOutlined /> : <FullscreenOutlined />}
            onClick={toggleFullscreen}
          >
            {isFullscreen ? '退出全屏' : '全屏'}
          </Button>
        </Space>
      </div>
      
      {/* Tab切换 */}
      <div className="mindmap-tabs-container">
        <Tabs
          activeKey={contentType}
          onChange={handleTabChange}
          items={tabItems}
          size="large"
        />
      </div>
      
      {/* 主体内容区 */}
      <Layout className="mindmap-main-layout">
        {/* 左侧编辑器 */}
        <Sider width="50%" theme="light" className="mindmap-editor-sider">
          <div className="editor-header">
            <Text strong style={{ fontSize: 15 }}>
              {contentType === 'markdown' && 'Markdown 编辑器'}
              {contentType === 'mermaid' && 'Mermaid DSL 编辑器'}
              {contentType === 'svg' && 'SVG 代码编辑器'}
            </Text>
            <Tooltip title="支持实时预览">
              <QuestionCircleOutlined style={{ color: '#8E8E93' }} />
            </Tooltip>
          </div>
          <div className="editor-wrapper" ref={editorWrapperRef} style={{ height: editorHeight }}>
            {editorLoading && (
              <div className="editor-loading">
                <Spin tip="加载编辑器..." />
              </div>
            )}
            <Editor
              height={editorHeight}
              language={getEditorLanguage()}
              theme="vs-light"
              value={content}
              onChange={(value) => setContent(value || '')}
              onMount={handleEditorDidMount}
              loading={null}
              options={{
                minimap: { enabled: false },
                fontSize: 14,
                fontFamily: 'SF Mono, Monaco, Consolas, monospace',
                lineNumbers: 'on',
                renderLineHighlight: 'all',
                scrollBeyondLastLine: false,
                wordWrap: 'on',
                automaticLayout: true,
                tabSize: 2,
                insertSpaces: true,
                folding: true,
                lineHeight: 22,
                letterSpacing: 0.3,
                cursorBlinking: 'smooth',
                smoothScrolling: true,
                padding: { top: 16, bottom: 16 },
                scrollbar: {
                  verticalScrollbarSize: 10,
                  horizontalScrollbarSize: 10
                }
              }}
            />
          </div>
        </Sider>
        
        {/* 右侧预览区 */}
        <Content className="mindmap-preview-content">
          <div className="mindmap-toolbar">
            <Space size={16}>
              <Text strong style={{ fontSize: 15 }}>
                实时预览
              </Text>
              <div className="toolbar-divider" />
              {contentType === 'markdown' && (
                <Space size={8}>
                  <Tooltip title="放大">
                    <Button 
                      className="zoom-button"
                      icon={<ZoomInOutlined />} 
                      onClick={() => handleZoom('in')}
                    />
                  </Tooltip>
                  <Tooltip title="缩小">
                    <Button 
                      className="zoom-button"
                      icon={<ZoomOutOutlined />} 
                      onClick={() => handleZoom('out')}
                    />
                  </Tooltip>
                  <Tooltip title="自适应">
                    <Button 
                      className="zoom-button"
                      icon={<ReloadOutlined />} 
                      onClick={() => handleZoom('fit')}
                    />
                  </Tooltip>
                  <Tooltip title="展开所有">
                    <Button 
                      className="zoom-button"
                      icon={<ExpandOutlined />} 
                      onClick={handleExpandAll}
                    />
                  </Tooltip>
                </Space>
              )}
            </Space>
          </div>
          {renderPreview()}
        </Content>
      </Layout>
    </div>
  );
};

export default MindmapPage;

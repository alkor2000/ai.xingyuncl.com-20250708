/**
 * Mermaid 图表预览组件
 * 支持实时渲染各种类型的 Mermaid 图表
 */

import React, { useEffect, useRef, useState } from 'react';
import { Spin, Empty } from 'antd';
import mermaid from 'mermaid';

const MermaidPreview = ({ code }) => {
  const containerRef = useRef(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const renderTimeoutRef = useRef(null);
  const renderCountRef = useRef(0);

  // 初始化 Mermaid 配置（只执行一次）
  useEffect(() => {
    mermaid.initialize({
      startOnLoad: false,
      theme: 'default',
      securityLevel: 'loose',
      fontFamily: 'Arial, sans-serif, "Microsoft YaHei", "微软雅黑"',
      flowchart: {
        useMaxWidth: false,
        htmlLabels: true,
        curve: 'basis',
        padding: 15
      },
      sequence: {
        useMaxWidth: false,
        wrap: true,
        width: 150
      },
      gantt: {
        useMaxWidth: false,
        fontSize: 12
      },
      logLevel: 'error'
    });
  }, []);

  // 渲染 Mermaid 图表
  useEffect(() => {
    // 如果代码为空，直接设置 loading=false
    if (!code || code.trim() === '') {
      setLoading(false);
      return;
    }

    // 清除之前的渲染超时
    if (renderTimeoutRef.current) {
      clearTimeout(renderTimeoutRef.current);
    }

    // 设置加载状态
    setLoading(true);

    // 防抖渲染（300ms）
    renderTimeoutRef.current = setTimeout(async () => {
      // 在这里检查 containerRef，如果还没准备好就等待
      if (!containerRef.current) {
        console.warn('Container ref 未就绪，延迟 100ms 重试');
        renderTimeoutRef.current = setTimeout(() => {
          // 递归调用，但为了避免无限循环，只重试一次
          if (!containerRef.current) {
            console.error('Container ref 始终未就绪');
            setLoading(false);
            return;
          }
          // 手动触发渲染
          renderMermaid();
        }, 100);
        return;
      }

      // 正常渲染
      await renderMermaid();
    }, 300);

    return () => {
      if (renderTimeoutRef.current) {
        clearTimeout(renderTimeoutRef.current);
      }
    };
  }, [code]);

  // 实际渲染函数
  const renderMermaid = async () => {
    try {
      setError(null);

      // 清空容器
      if (containerRef.current) {
        containerRef.current.innerHTML = '';
      }

      // 生成唯一ID
      renderCountRef.current += 1;
      const id = `mermaid-preview-${Date.now()}-${renderCountRef.current}`;

      // 创建临时容器
      const tempContainer = document.createElement('div');
      tempContainer.id = id;
      tempContainer.style.display = 'none';
      document.body.appendChild(tempContainer);

      try {
        // 渲染图表
        const { svg } = await mermaid.render(id, code);
        
        // 移除临时容器
        if (tempContainer && tempContainer.parentNode) {
          tempContainer.parentNode.removeChild(tempContainer);
        }

        // 将SVG插入到实际容器
        if (containerRef.current) {
          containerRef.current.innerHTML = svg;
          
          // 优化SVG显示 - 自适应容器
          const svgElement = containerRef.current.querySelector('svg');
          if (svgElement) {
            // 获取原始尺寸
            const width = svgElement.getAttribute('width');
            const height = svgElement.getAttribute('height');
            
            // 设置viewBox以支持缩放
            if (width && height && !svgElement.getAttribute('viewBox')) {
              svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
            }
            
            // 移除固定尺寸，使用百分比
            svgElement.removeAttribute('width');
            svgElement.removeAttribute('height');
            
            // 设置样式
            svgElement.style.width = '100%';
            svgElement.style.height = 'auto';
            svgElement.style.maxWidth = '100%';
            svgElement.style.maxHeight = '100%';
            svgElement.style.display = 'block';
            svgElement.style.margin = '0 auto';
          }
        }

        setLoading(false);
      } catch (renderError) {
        // 清理临时容器
        if (tempContainer && tempContainer.parentNode) {
          tempContainer.parentNode.removeChild(tempContainer);
        }
        throw renderError;
      }

    } catch (err) {
      console.error('Mermaid 渲染失败:', err);
      const errorMessage = err.message || err.toString();
      setError(errorMessage);
      setLoading(false);

      // 显示友好的错误提示
      if (containerRef.current) {
        containerRef.current.innerHTML = `
          <div style="
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 400px;
            color: #ff4d4f;
            padding: 20px;
            text-align: center;
          ">
            <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
            <div style="font-size: 16px; margin-bottom: 8px; font-weight: 600;">Mermaid 图表渲染失败</div>
            <div style="font-size: 14px; color: #999; max-width: 500px; word-break: break-word;">
              ${errorMessage}
            </div>
            <div style="font-size: 12px; color: #999; margin-top: 16px;">
              请检查 Mermaid 语法是否正确
            </div>
          </div>
        `;
      }
    }
  };

  if (loading) {
    return (
      <div style={{ 
        display: 'flex', 
        alignItems: 'center', 
        justifyContent: 'center',
        height: '100%',
        minHeight: '400px'
      }}>
        <Spin size="large" tip="渲染图表中..." />
      </div>
    );
  }

  // 如果代码为空，显示空状态
  if (!code || code.trim() === '') {
    return (
      <div style={{ 
        display: 'flex', 
        alignItems: 'center', 
        justifyContent: 'center',
        height: '100%',
        minHeight: '400px'
      }}>
        <Empty description="请输入 Mermaid 代码" />
      </div>
    );
  }

  return (
    <div 
      ref={containerRef} 
      style={{
        width: '100%',
        height: '100%',
        overflow: 'auto',
        display: 'flex',
        alignItems: 'flex-start',
        justifyContent: 'center',
        padding: '20px',
        minHeight: '400px'
      }}
    />
  );
};

export default MermaidPreview;

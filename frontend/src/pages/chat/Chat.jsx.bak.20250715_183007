import React, { useEffect, useState, useRef, useCallback, useMemo } from 'react'
import { 
  Layout, 
  Card, 
  Input, 
  Button, 
  Typography, 
  Space, 
  Avatar,
  Modal,
  Form,
  Select,
  message,
  Spin,
  Empty,
  Tag,
  Alert,
  InputNumber,
  Tooltip
} from 'antd'
import {
  SendOutlined,
  RobotOutlined,
  UserOutlined,
  ExclamationCircleOutlined,
  HistoryOutlined,
  InfoCircleOutlined,
  FireOutlined,
  PlusOutlined,
  LoadingOutlined,
  StopOutlined,
  SaveOutlined
} from '@ant-design/icons'
import { useTranslation } from 'react-i18next'
import { debounce } from 'lodash'
import useChatStore from '../../stores/chatStore'
import useAuthStore from '../../stores/authStore'
import MessageList from '../../components/chat/MessageList'
import ConversationList from '../../components/chat/ConversationList'

const { Sider, Content } = Layout
const { Title, Text } = Typography
const { TextArea } = Input

// è¾“å…¥æ¡†ç»„ä»¶ - æ”¯æŒè‡ªåŠ¨ä¿å­˜è‰ç¨¿
const ChatInput = React.memo(({ 
  onSendMessage, 
  isGenerating,
  disabled,
  onStopGeneration,
  conversationId // æ–°å¢ï¼šç”¨äºä¿å­˜è‰ç¨¿
}) => {
  const [messageInput, setMessageInput] = useState('')
  const { t } = useTranslation()
  const { saveDraft, getDraft, draftSaving } = useChatStore()
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)
  
  // åŠ è½½è‰ç¨¿
  useEffect(() => {
    if (conversationId) {
      const draft = getDraft(conversationId)
      if (draft) {
        setMessageInput(draft)
        setHasUnsavedChanges(false)
      } else {
        setMessageInput('')
        setHasUnsavedChanges(false)
      }
    }
  }, [conversationId, getDraft])
  
  // é˜²æŠ–ä¿å­˜è‰ç¨¿ï¼ˆ1ç§’åä¿å­˜ï¼‰
  const debouncedSaveDraft = useCallback(
    debounce(async (convId, content) => {
      if (convId && content.trim()) {
        await saveDraft(convId, content)
        setHasUnsavedChanges(false)
      }
    }, 1000),
    [saveDraft]
  )
  
  // è¾“å…¥å˜åŒ–æ—¶è§¦å‘è‡ªåŠ¨ä¿å­˜
  const handleInputChange = useCallback((e) => {
    const newValue = e.target.value
    setMessageInput(newValue)
    setHasUnsavedChanges(true)
    
    // è§¦å‘é˜²æŠ–ä¿å­˜
    if (conversationId) {
      debouncedSaveDraft(conversationId, newValue)
    }
  }, [conversationId, debouncedSaveDraft])
  
  const handleSend = useCallback(() => {
    if (!messageInput.trim() || isGenerating) return
    onSendMessage(messageInput.trim())
    setMessageInput('')
    setHasUnsavedChanges(false)
  }, [messageInput, isGenerating, onSendMessage])
  
  const handleKeyPress = useCallback((e) => {
    if (e.key === 'Enter') {
      if (e.shiftKey) {
        return
      } else {
        e.preventDefault()
        if (!isGenerating) {
          handleSend()
        }
      }
    }
  }, [isGenerating, handleSend])
  
  // ç»„ä»¶å¸è½½æ—¶ä¿å­˜è‰ç¨¿
  useEffect(() => {
    return () => {
      debouncedSaveDraft.cancel()
    }
  }, [debouncedSaveDraft])
  
  return (
    <div className="chat-input-container">
      <TextArea
        value={messageInput}
        onChange={handleInputChange}
        placeholder={t('chat.input.placeholder')}
        autoSize={{ minRows: 3, maxRows: 8 }}
        onKeyDown={handleKeyPress}
        disabled={disabled || isGenerating}
        className="chat-input-textarea"
      />
      <div className="chat-input-actions">
        {isGenerating ? (
          <Button 
            type="primary"
            danger
            icon={<StopOutlined />}
            onClick={onStopGeneration}
            className="chat-input-send-button"
          >
            {t('chat.stop')}
          </Button>
        ) : (
          <Button 
            type="primary" 
            icon={<SendOutlined />}
            onClick={handleSend}
            disabled={disabled || !messageInput.trim()}
            className="chat-input-send-button"
          >
            {t('chat.send')}
          </Button>
        )}
        {/* è‰ç¨¿ä¿å­˜æŒ‡ç¤ºå™¨ */}
        {messageInput.trim() && (
          <div className="draft-indicator">
            {draftSaving ? (
              <Space size="small">
                <LoadingOutlined style={{ fontSize: 12 }} />
                <Text type="secondary" style={{ fontSize: 12 }}>
                  {t('chat.draft.saving')}
                </Text>
              </Space>
            ) : hasUnsavedChanges ? (
              <Text type="secondary" style={{ fontSize: 12 }}>
                {t('chat.draft.unsaved')}
              </Text>
            ) : (
              <Space size="small">
                <SaveOutlined style={{ fontSize: 12, color: '#52c41a' }} />
                <Text type="secondary" style={{ fontSize: 12 }}>
                  {t('chat.draft.saved')}
                </Text>
              </Space>
            )}
          </div>
        )}
      </div>
    </div>
  )
})

ChatInput.displayName = 'ChatInput'

const Chat = () => {
  const { user } = useAuthStore()
  const { t } = useTranslation()
  const {
    conversations,
    conversationsLoading,
    currentConversationId,
    currentConversation,
    messages,
    messagesLoading,
    aiModels,
    userCredits,
    typing,
    creditsLoading,
    streamingMessageId,
    isStreaming,
    getConversations,
    createConversation,
    selectConversation,
    sendMessage,
    stopGeneration,
    updateConversation,
    deleteConversation,
    getAIModels,
    getUserCredits,
    checkCreditsForModel,
    getModelCredits
  } = useChatStore()

  const [isModalVisible, setIsModalVisible] = useState(false)
  const [form] = Form.useForm()
  const [editingConversation, setEditingConversation] = useState(null)
  
  // åˆ é™¤ç¡®è®¤å¯¹è¯æ¡†çŠ¶æ€
  const [deleteModalVisible, setDeleteModalVisible] = useState(false)
  const [conversationToDelete, setConversationToDelete] = useState(null)
  const [deleting, setDeleting] = useState(false)
  
  // ç”¨æˆ·æ‰‹åŠ¨æ»šåŠ¨æ ‡å¿—
  const [userScrolled, setUserScrolled] = useState(false)
  
  // å¯¹è¯åˆ‡æ¢æ ‡å¿—
  const [isConversationSwitching, setIsConversationSwitching] = useState(false)
  
  // æ¶ˆæ¯åˆ—è¡¨è‡ªåŠ¨æ»šåŠ¨å¼•ç”¨
  const messagesEndRef = useRef(null)
  const messagesContainerRef = useRef(null)

  // ğŸ”¥ åˆ¤æ–­æ˜¯å¦æ­£åœ¨ç”Ÿæˆï¼ˆåŒ…æ‹¬æµå¼å’Œéæµå¼ï¼‰
  const isGenerating = typing || isStreaming

  // ğŸ”¥ ç»„ä»¶åŠ è½½æ—¶è·å–æ•°æ® - åŒæ—¶åŠ è½½ç§¯åˆ†ä¿¡æ¯é¿å…é¦–æ¬¡æ˜¾ç¤ºç§¯åˆ†ä¸è¶³
  useEffect(() => {
    // å¹¶è¡ŒåŠ è½½æ‰€æœ‰å¿…è¦æ•°æ®
    Promise.all([
      getConversations(),
      getAIModels(),
      getUserCredits() // ç«‹å³åŠ è½½ç§¯åˆ†ä¿¡æ¯
    ]).catch(error => {
      console.error('åˆå§‹åŒ–æ•°æ®åŠ è½½å¤±è´¥:', error)
    })
  }, [getConversations, getAIModels, getUserCredits])

  // ä¿®æ”¹æ»šåŠ¨å‡½æ•°ï¼Œæ”¯æŒå¼ºåˆ¶ç«‹å³æ»šåŠ¨
  const scrollToBottom = useCallback((instant = false, force = false) => {
    if (messagesEndRef.current && (!userScrolled || force)) {
      // å¦‚æœæ˜¯å¯¹è¯åˆ‡æ¢æˆ–å¼ºåˆ¶æ»šåŠ¨ï¼Œä½¿ç”¨instant
      const behavior = instant || force ? 'instant' : (isStreaming ? 'instant' : 'smooth')
      messagesEndRef.current.scrollIntoView({ 
        behavior,
        block: 'end'
      })
    }
  }, [userScrolled, isStreaming])

  // ç›‘å¬ç”¨æˆ·æ»šåŠ¨
  useEffect(() => {
    const container = messagesContainerRef.current
    if (!container) return

    const handleScroll = () => {
      const { scrollTop, scrollHeight, clientHeight } = container
      const isAtBottom = scrollHeight - scrollTop - clientHeight < 100 // 100pxå®¹å·®
      
      // å¦‚æœç”¨æˆ·æ‰‹åŠ¨å‘ä¸Šæ»šåŠ¨äº†ï¼Œè®¾ç½®æ ‡å¿—
      if (!isAtBottom && isStreaming) {
        setUserScrolled(true)
      }
      // å¦‚æœæ»šåŠ¨åˆ°åº•éƒ¨äº†ï¼Œæ¸…é™¤æ ‡å¿—
      else if (isAtBottom) {
        setUserScrolled(false)
      }
    }

    container.addEventListener('scroll', handleScroll)
    return () => container.removeEventListener('scroll', handleScroll)
  }, [isStreaming])

  // æµå¼è¾“å‡ºç»“æŸæ—¶ï¼Œé‡ç½®ç”¨æˆ·æ»šåŠ¨æ ‡å¿—
  useEffect(() => {
    if (!isStreaming) {
      setUserScrolled(false)
    }
  }, [isStreaming])

  // å¯¹è¯åˆ‡æ¢å®Œæˆåï¼Œé‡ç½®åˆ‡æ¢æ ‡å¿—
  useEffect(() => {
    if (!messagesLoading && isConversationSwitching) {
      // å¯¹è¯åˆ‡æ¢å®Œæˆï¼Œç›´æ¥è·³åˆ°åº•éƒ¨
      setTimeout(() => {
        scrollToBottom(true, true)
        setIsConversationSwitching(false)
      }, 50)
    }
  }, [messagesLoading, isConversationSwitching, scrollToBottom])

  // è‡ªåŠ¨æ»šåŠ¨åˆ°æ¶ˆæ¯åº•éƒ¨ - åªåœ¨ä¸æ˜¯ç”¨æˆ·æ‰‹åŠ¨æ»šåŠ¨ä¸”ä¸æ˜¯åˆ‡æ¢å¯¹è¯æ—¶æ‰§è¡Œ
  useEffect(() => {
    if (!userScrolled && !isConversationSwitching) {
      scrollToBottom(isStreaming)
    }
  }, [messages, typing, isStreaming, userScrolled, isConversationSwitching, scrollToBottom])
  
  // æµå¼è¾“å‡ºæ—¶é™ä½æ»šåŠ¨é¢‘ç‡
  useEffect(() => {
    if (isStreaming && streamingMessageId && !userScrolled && !isConversationSwitching) {
      const scrollInterval = setInterval(() => {
        if (!userScrolled) {
          scrollToBottom(true)
        }
      }, 500) // æ¯500msæ»šåŠ¨ä¸€æ¬¡
      
      return () => clearInterval(scrollInterval)
    }
  }, [isStreaming, streamingMessageId, userScrolled, isConversationSwitching, scrollToBottom])

  // ğŸ”¥ é€‰æ‹©ä¼šè¯å¤„ç† - è®¾ç½®åˆ‡æ¢æ ‡å¿—
  const handleSelectConversation = useCallback((conversationId) => {
    if (conversationId !== currentConversationId) {
      setIsConversationSwitching(true)
      setUserScrolled(false) // é‡ç½®ç”¨æˆ·æ»šåŠ¨çŠ¶æ€
    }
    selectConversation(conversationId)
  }, [selectConversation, currentConversationId])

  // åˆ›å»ºæ–°ä¼šè¯ - ä¿ç•™ç§¯åˆ†æ£€æŸ¥ä½†ä¸æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
  const handleCreateConversation = async (values) => {
    try {
      // é™é»˜æ£€æŸ¥ç§¯åˆ†æ˜¯å¦è¶³å¤Ÿ
      if (!checkCreditsForModel(values.model_name)) {
        // æ­¤æ—¶è·å–ä¸€æ¬¡ç§¯åˆ†çŠ¶æ€ç”¨äºé”™è¯¯æç¤º
        await getUserCredits()
        const requiredCredits = getModelCredits(values.model_name)
        message.error(t('chat.credits.insufficientCreate'))
        return
      }

      await createConversation({
        title: values.title || 'New Chat',
        model_name: values.model_name || 'gpt-3.5-turbo',
        system_prompt: values.system_prompt,
        context_length: values.context_length || 20,
        ai_temperature: parseFloat(values.ai_temperature) || 0.0
      })
      setIsModalVisible(false)
      form.resetFields()
      message.success(t('chat.conversation.create.success'))
    } catch (error) {
      message.error(error.response?.data?.message || t('chat.conversation.create.failed'))
    }
  }

  // å‘é€æ¶ˆæ¯ - ä½¿ç”¨ useCallback
  const handleSendMessage = useCallback(async (content) => {
    if (!content || !currentConversation) {
      return
    }

    // é™é»˜æ£€æŸ¥ç§¯åˆ†æ˜¯å¦å……è¶³
    if (!checkCreditsForModel(currentConversation.model_name)) {
      message.error(t('chat.credits.insufficient'))
      return
    }

    try {
      // å‘é€å‰é‡ç½®ç”¨æˆ·æ»šåŠ¨æ ‡å¿—
      setUserScrolled(false)
      
      // sendMessageæ–¹æ³•ä¼šè‡ªåŠ¨åˆ¤æ–­æ˜¯å¦ä½¿ç”¨æµå¼
      await sendMessage(content)
      
      // éæµå¼æ—¶æ˜¾ç¤ºæˆåŠŸæç¤º
      const model = aiModels.find(m => m.name === currentConversation.model_name)
      if (!model?.stream_enabled) {
        message.success(t('chat.message.sendSuccess'))
      }
      
      // å‘é€åç«‹å³æ»šåŠ¨åˆ°åº•éƒ¨
      setTimeout(() => scrollToBottom(false), 100)
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message || t('chat.message.sendFailed')
      message.error(errorMessage)
      
      // å¦‚æœæ˜¯ç§¯åˆ†ç›¸å…³é”™è¯¯ï¼Œé™é»˜åˆ·æ–°ç§¯åˆ†çŠ¶æ€
      if (errorMessage.includes('ç§¯åˆ†')) {
        getUserCredits()
      }
    }
  }, [currentConversation, checkCreditsForModel, sendMessage, aiModels, scrollToBottom, getUserCredits, t])

  // ğŸ”¥ åœæ­¢ç”Ÿæˆï¼ˆæ”¯æŒæµå¼å’Œéæµå¼ï¼‰
  const handleStopGeneration = useCallback(() => {
    stopGeneration()
    message.info(t('chat.message.stopped'))
  }, [stopGeneration, t])

  // ç¼–è¾‘ä¼šè¯
  const handleEditConversation = useCallback((conversation) => {
    setEditingConversation(conversation)
    form.setFieldsValue({
      title: conversation.title,
      model_name: conversation.model_name,
      system_prompt: conversation.system_prompt,
      context_length: conversation.context_length || 20,
      ai_temperature: conversation.ai_temperature !== undefined ? conversation.ai_temperature : 0.0
    })
    setIsModalVisible(true)
  }, [form])

  // æ›´æ–°ä¼šè¯
  const handleUpdateConversation = async (values) => {
    try {
      // ç¡®ä¿ai_temperatureæ˜¯æ•°å­—ç±»å‹
      const updateData = {
        ...values,
        ai_temperature: parseFloat(values.ai_temperature) || 0.0
      }
      
      await updateConversation(editingConversation.id, updateData)
      setIsModalVisible(false)
      setEditingConversation(null)
      form.resetFields()
      message.success(t('chat.conversation.update.success'))
    } catch (error) {
      message.error(t('chat.conversation.update.failed'))
    }
  }

  // åˆ é™¤ä¼šè¯
  const handleDeleteConversation = useCallback((conversationId) => {
    const targetConversation = conversations.find(c => c.id === conversationId)
    setConversationToDelete(targetConversation)
    setDeleteModalVisible(true)
  }, [conversations])

  // ç¡®è®¤åˆ é™¤ä¼šè¯
  const confirmDeleteConversation = async () => {
    if (!conversationToDelete) return
    
    try {
      setDeleting(true)
      await deleteConversation(conversationToDelete.id)
      
      setDeleteModalVisible(false)
      setConversationToDelete(null)
      setDeleting(false)
      message.success(t('chat.conversation.delete.success'))
      
    } catch (error) {
      console.error('âŒ åˆ é™¤æ“ä½œå¤±è´¥:', error)
      setDeleting(false)
      message.error(t('chat.conversation.delete.failed', { error: error.message || t('error.unknown') }))
    }
  }

  // å–æ¶ˆåˆ é™¤
  const cancelDeleteConversation = () => {
    setDeleteModalVisible(false)
    setConversationToDelete(null)
  }

  // åˆ›å»ºæ–°å¯¹è¯å¤„ç†
  const handleCreateNew = useCallback(() => {
    setEditingConversation(null)
    form.resetFields()
    setIsModalVisible(true)
  }, [form])

  // ğŸ”¥ æ£€æŸ¥æ˜¯å¦å¯ä»¥å‘é€æ¶ˆæ¯ - æ”¹è¿›é€»è¾‘ï¼Œè€ƒè™‘åŠ è½½çŠ¶æ€
  const canSendMessage = useMemo(() => {
    if (!currentConversation) return false
    
    // å¦‚æœç§¯åˆ†æ­£åœ¨åŠ è½½ä¸­ï¼Œæš‚æ—¶å…è®¸ï¼ˆä¸æ˜¾ç¤ºç§¯åˆ†ä¸è¶³è­¦å‘Šï¼‰
    if (creditsLoading || !userCredits) return true
    
    return checkCreditsForModel(currentConversation.model_name)
  }, [currentConversation, checkCreditsForModel, creditsLoading, userCredits])

  // è·å–temperatureæ ‡ç­¾é¢œè‰²
  const getTemperatureTagColor = (temp) => {
    if (temp === 0) return 'purple'
    if (temp <= 0.3) return 'blue'
    if (temp <= 0.7) return 'cyan'
    return 'volcano'
  }

  // è·å–temperatureæè¿°
  const getTemperatureDesc = (temp) => {
    if (temp === 0) return t('chat.temperature.strict')
    if (temp <= 0.3) return t('chat.temperature.precise')
    if (temp <= 0.7) return t('chat.temperature.balanced')
    return t('chat.temperature.creative')
  }

  // è‡ªå®šä¹‰TemperatureéªŒè¯å‡½æ•°
  const validateTemperature = (_, value) => {
    if (value === '' || value === null || value === undefined) {
      return Promise.reject(new Error(t('chat.settings.temperature.required')))
    }
    
    const numValue = parseFloat(value)
    if (isNaN(numValue)) {
      return Promise.reject(new Error(t('chat.settings.temperature.invalid')))
    }
    
    if (numValue < 0 || numValue > 1) {
      return Promise.reject(new Error(t('chat.settings.temperature.range')))
    }
    
    return Promise.resolve()
  }

  // è·å–å½“å‰æ¨¡å‹æ˜¯å¦æ”¯æŒæµå¼
  const isStreamEnabled = () => {
    if (!currentConversation) return false
    const model = aiModels.find(m => m.name === currentConversation.model_name)
    return model?.stream_enabled === true
  }

  return (
    <Layout className="chat-layout">
      {/* ğŸ”¥ ä¾§è¾¹æ  - ä½¿ç”¨ç‹¬ç«‹ç»„ä»¶ï¼ŒçŠ¶æ€å®Œå…¨éš”ç¦» */}
      <Sider width={350}>
        <ConversationList 
          conversations={conversations}
          conversationsLoading={conversationsLoading}
          currentConversationId={currentConversationId}
          onSelectConversation={handleSelectConversation}
          onEditConversation={handleEditConversation}
          onDeleteConversation={handleDeleteConversation}
          onCreateConversation={handleCreateNew}
          getModelCredits={getModelCredits}
        />
      </Sider>

      {/* ğŸ”¥ èŠå¤©åŒºåŸŸ - æ–°çš„ç®€æ´åŠ è½½çŠ¶æ€ */}
      <Content className="chat-main">
        {messagesLoading ? (
          <div style={{ 
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'center', 
            height: '100%',
            flexDirection: 'column',
            gap: '16px'
          }}>
            <Spin size="large" tip={t('chat.loading')} />
            <Text type="secondary">{t('chat.loadingHistory')}</Text>
          </div>
        ) : currentConversation ? (
          <>
            {/* ä¼šè¯å¤´éƒ¨ - å›ºå®šåœ¨é¡¶éƒ¨ï¼Œç®€åŒ–æ˜¾ç¤º */}
            <div className="chat-header">
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <div>
                  <Title level={4} style={{ margin: 0 }}>
                    {currentConversation.title}
                  </Title>
                  <Space>
                    <Text type="secondary">
                      {currentConversation.model_name} â€¢ {t('chat.messages.count', { count: messages.length })}
                    </Text>
                    {isStreamEnabled() && (
                      <Tag color="green" icon={<LoadingOutlined />}>
                        {t('chat.model.streaming')}
                      </Tag>
                    )}
                    <Tooltip title={t('chat.settings.contextLength.tooltip')}>
                      <Tag color="cyan" icon={<HistoryOutlined />}>
                        {t('chat.context.count', { count: currentConversation.context_length || 20 })}
                      </Tag>
                    </Tooltip>
                    <Tooltip title={t('chat.settings.temperature.tooltip')}>
                      <Tag 
                        color={getTemperatureTagColor(currentConversation.ai_temperature || 0.0)} 
                        icon={<FireOutlined />}
                      >
                        {getTemperatureDesc(currentConversation.ai_temperature || 0.0)} {currentConversation.ai_temperature || 0.0}
                      </Tag>
                    </Tooltip>
                  </Space>
                </div>
              </div>
            </div>

            {/* æ¶ˆæ¯åˆ—è¡¨ - å›ºå®šå¯æ»šåŠ¨åŒºåŸŸ */}
            <div className="chat-messages">
              <div className="chat-messages-content" ref={messagesContainerRef}>
                <MessageList 
                  messages={messages}
                  typing={typing}
                  isStreaming={isStreaming}
                  streamingMessageId={streamingMessageId}
                  messagesEndRef={messagesEndRef}
                />
              </div>
            </div>

            {/* è¾“å…¥æ¡† - å›ºå®šåœ¨åº•éƒ¨ */}
            <div className="chat-input">
              {/* ğŸ”¥ ç§¯åˆ†ä¸è¶³è­¦å‘Š - åªåœ¨ç§¯åˆ†å·²åŠ è½½ä¸”ç¡®å®ä¸è¶³æ—¶æ˜¾ç¤º */}
              {currentConversation && userCredits && !checkCreditsForModel(currentConversation.model_name) && (
                <Alert
                  message={t('chat.credits.insufficient')}
                  type="error"
                  showIcon
                  style={{ marginBottom: 12 }}
                  action={
                    <Button size="small" type="primary" ghost>
                      {t('chat.credits.contact')}
                    </Button>
                  }
                />
              )}

              <ChatInput 
                onSendMessage={handleSendMessage}
                isGenerating={isGenerating}
                disabled={!canSendMessage}
                onStopGeneration={handleStopGeneration}
                conversationId={currentConversationId}
              />
              
              {/* è¾“å…¥æç¤º - è¿›ä¸€æ­¥ç®€åŒ– */}
              <div className="chat-input-tip">
                <span>{t('chat.input.tip')}</span>
                {currentConversation && (
                  <span>
                    {isStreamEnabled() ? t('chat.model.streamingEnabled') : t('chat.model.standard')} â€¢ 
                    {t('chat.context.count', { count: currentConversation.context_length || 20 })} â€¢ 
                    {getTemperatureDesc(currentConversation.ai_temperature || 0.0)}: {currentConversation.ai_temperature || 0.0}
                  </span>
                )}
              </div>
            </div>
          </>
        ) : (
          <div className="chat-empty-state">
            <Empty 
              description={t('chat.selectConversation')}
              image={Empty.PRESENTED_IMAGE_SIMPLE}
            />
            <Button 
              type="primary" 
              icon={<PlusOutlined />}
              style={{ marginTop: 16 }}
              onClick={handleCreateNew}
            >
              {t('chat.createConversation')}
            </Button>
          </div>
        )}
      </Content>

      {/* ğŸ”¥ ä¼šè¯è®¾ç½®å¯¹è¯æ¡† - ä¿®å¤TemperatureéªŒè¯ */}
      <Modal
        title={editingConversation ? t('chat.settings.title') : t('chat.settings.create')}
        open={isModalVisible}
        onCancel={() => {
          setIsModalVisible(false)
          setEditingConversation(null)
          form.resetFields()
        }}
        footer={null}
        width={600}
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={editingConversation ? handleUpdateConversation : handleCreateConversation}
          initialValues={{
            context_length: 20,
            ai_temperature: 0.0
          }}
        >
          <Form.Item
            name="title"
            label={t('chat.settings.conversationTitle')}
            rules={[{ required: true, message: t('chat.settings.conversationTitle.required') }]}
          >
            <Input placeholder={t('chat.settings.conversationTitle')} />
          </Form.Item>

          <Form.Item
            name="model_name"
            label={t('chat.settings.selectModel')}
            rules={[{ required: true, message: t('chat.settings.selectModel.required') }]}
          >
            <Select placeholder={t('chat.settings.selectModel.placeholder')}>
              {aiModels.map(model => (
                <Select.Option key={model.name} value={model.name}>
                  <Space>
                    <span>{model.display_name}</span>
                    {model.stream_enabled && (
                      <Tag color="green" size="small">{t('chat.model.streaming')}</Tag>
                    )}
                  </Space>
                </Select.Option>
              ))}
            </Select>
          </Form.Item>

          {/* ğŸ”¥ ç®€åŒ–ä¸Šä¸‹æ–‡æ•°é‡è®¾ç½® - ä¿®æ”¹å¤‡æ³¨ä¿¡æ¯ */}
          <Form.Item
            name="context_length"
            label={
              <Space>
                <span>{t('chat.settings.contextLength')}</span>
                <Tooltip title={t('chat.settings.contextLength.tooltip')}>
                  <InfoCircleOutlined style={{ color: '#999' }} />
                </Tooltip>
              </Space>
            }
            rules={[
              { required: true, message: t('chat.settings.contextLength.required') },
              { type: 'number', min: 1, max: 500, message: t('chat.settings.contextLength.range') }
            ]}
            extra={t('chat.settings.contextLength.range')}
          >
            <InputNumber
              min={1}
              max={500}
              style={{ width: '100%' }}
              placeholder="20"
            />
          </Form.Item>

          {/* ğŸ”¥ ä¿®å¤Temperatureè®¾ç½® - ä½¿ç”¨è‡ªå®šä¹‰éªŒè¯ */}
          <Form.Item
            name="ai_temperature"
            label={
              <Space>
                <FireOutlined style={{ color: '#ff7a00' }} />
                <span>{t('chat.settings.temperature')}</span>
                <Tooltip title={t('chat.settings.temperature.tooltip')}>
                  <InfoCircleOutlined style={{ color: '#999' }} />
                </Tooltip>
              </Space>
            }
            rules={[
              { validator: validateTemperature }
            ]}
            extra={t('chat.settings.temperature.tip')}
          >
            <Input
              placeholder="0.0"
              style={{ width: 200 }}
            />
          </Form.Item>

          <Form.Item
            name="system_prompt"
            label={t('chat.settings.systemPrompt')}
          >
            <TextArea 
              placeholder={t('chat.settings.systemPrompt.placeholder')}
              autoSize={{ minRows: 3, maxRows: 6 }}
            />
          </Form.Item>

          <Form.Item>
            <Space>
              <Button type="primary" htmlType="submit">
                {editingConversation ? t('button.save') : t('button.create')}
              </Button>
              <Button onClick={() => {
                setIsModalVisible(false)
                setEditingConversation(null)
                form.resetFields()
              }}>
                {t('button.cancel')}
              </Button>
            </Space>
          </Form.Item>
        </Form>
      </Modal>

      {/* åˆ é™¤ç¡®è®¤å¯¹è¯æ¡† */}
      <Modal
        title={t('chat.delete.title')}
        open={deleteModalVisible}
        onOk={confirmDeleteConversation}
        onCancel={cancelDeleteConversation}
        okText={t('chat.delete.confirmButton')}
        cancelText={t('button.cancel')}
        okType="danger"
        confirmLoading={deleting}
        centered
      >
        <div style={{ display: 'flex', alignItems: 'center', marginBottom: 16 }}>
          <ExclamationCircleOutlined style={{ color: '#ff4d4f', fontSize: 22, marginRight: 8 }} />
          <span>{t('chat.delete.confirm')}</span>
        </div>
        {conversationToDelete && (
          <div>
            <p><strong>{t('chat.delete.conversationTitle')}</strong> {conversationToDelete.title}</p>
            <p><strong>{t('chat.delete.messageCount')}</strong> {conversationToDelete.message_count} {t('chat.messages.count', { count: conversationToDelete.message_count })}</p>
            <p><strong>{t('chat.delete.contextSetting')}</strong> {conversationToDelete.context_length || 20} {t('chat.context.count', { count: conversationToDelete.context_length || 20 })}</p>
            <p style={{ color: '#ff4d4f', marginTop: 16 }}>
              <strong>{t('chat.delete.warning')}</strong>
            </p>
          </div>
        )}
      </Modal>
    </Layout>
  )
}

export default Chat

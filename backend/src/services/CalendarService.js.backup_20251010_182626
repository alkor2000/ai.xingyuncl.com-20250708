/**
 * æ—¥å†æœåŠ¡å±‚ - AIåˆ†ææ ¸å¿ƒé€»è¾‘
 * è´Ÿè´£å¤„ç†AIåˆ†æè¯·æ±‚ã€ç§¯åˆ†æ‰£é™¤ã€ç»“æœå­˜å‚¨
 */

const CalendarEvent = require('../models/CalendarEvent');
const CalendarAIAnalysis = require('../models/CalendarAIAnalysis');
const AIModel = require('../models/AIModel');
const User = require('../models/User');
const AnthropicService = require('./anthropicService');
const OpenAIService = require('./openaiService');
const logger = require('../utils/logger');
const { ValidationError, DatabaseError } = require('../utils/errors');

class CalendarService {
  /**
   * è®¡ç®—AIåˆ†æéœ€è¦çš„ç§¯åˆ†
   * å…¬å¼: base_cost + (days / 7) * 5 + model_multiplier
   */
  static calculateAnalysisCredits(scanDays, modelCreditsPerChat) {
    const baseCost = 10;
    const daysCost = Math.ceil((scanDays * 2) / 7) * 5; // å‰åNå¤©ï¼Œæ‰€ä»¥æ˜¯2N
    const modelMultiplier = Math.ceil(modelCreditsPerChat / 10);
    
    return baseCost + daysCost + modelMultiplier;
  }

  /**
   * æ„å»ºAIåˆ†æçš„Prompt
   */
  static buildAnalysisPrompt(events, scanDateStart, scanDateEnd) {
    // ç»Ÿè®¡æ•°æ®
    const stats = {
      total: events.length,
      by_category: {},
      by_status: {},
      by_importance: {
        high: 0, // >= 8
        medium: 0, // 5-7
        low: 0 // < 5
      }
    };

    events.forEach(event => {
      // æŒ‰åˆ†ç±»ç»Ÿè®¡
      stats.by_category[event.category] = (stats.by_category[event.category] || 0) + 1;
      
      // æŒ‰çŠ¶æ€ç»Ÿè®¡
      stats.by_status[event.status] = (stats.by_status[event.status] || 0) + 1;
      
      // æŒ‰é‡è¦åº¦ç»Ÿè®¡
      if (event.importance >= 8) stats.by_importance.high++;
      else if (event.importance >= 5) stats.by_importance.medium++;
      else stats.by_importance.low++;
    });

    // æ ¼å¼åŒ–äº‹é¡¹åˆ—è¡¨
    const formattedEvents = events.map(event => ({
      date: event.event_date,
      content: event.content,
      importance: event.importance,
      category: event.category,
      status: event.status
    }));

    const prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„æ—¶é—´ç®¡ç†é¡¾é—®å’Œæ—¥ç¨‹è§„åˆ’ä¸“å®¶ã€‚è¯·åˆ†æç”¨æˆ·çš„æ—¥å†äº‹é¡¹ï¼Œæä¾›æ·±åº¦æ´å¯Ÿå’Œä¼˜åŒ–å»ºè®®ã€‚

ã€æ•°æ®æ¦‚è§ˆã€‘
- åˆ†ææ—¶é—´èŒƒå›´ï¼š${scanDateStart} è‡³ ${scanDateEnd}
- äº‹é¡¹æ€»æ•°ï¼š${stats.total}
- åˆ†ç±»åˆ†å¸ƒï¼š${Object.entries(stats.by_category).map(([k, v]) => `${k}(${v})`).join('ã€')}
- çŠ¶æ€åˆ†å¸ƒï¼šå·²å®Œæˆ(${stats.by_status.completed || 0})ã€è¿›è¡Œä¸­(${stats.by_status.in_progress || 0})ã€æœªå¼€å§‹(${stats.by_status.not_started || 0})ã€æ—¥å¸¸(${stats.by_status.daily || 0})
- é‡è¦åº¦åˆ†å¸ƒï¼šé«˜ä¼˜(${stats.by_importance.high})ã€ä¸­ç­‰(${stats.by_importance.medium})ã€ä½ä¼˜(${stats.by_importance.low})

ã€è¯¦ç»†äº‹é¡¹æ•°æ®ã€‘
\`\`\`json
${JSON.stringify(formattedEvents, null, 2)}
\`\`\`

è¯·ä»ä»¥ä¸‹5ä¸ªç»´åº¦è¿›è¡Œæ·±åº¦åˆ†æï¼Œç”¨Markdownæ ¼å¼è¾“å‡ºï¼ŒåŒ…å«è¡¨æ ¼ã€åˆ—è¡¨ã€emojiå›¾æ ‡ï¼š

## ğŸ“Š 1. ä»»åŠ¡ä¼˜å…ˆçº§æ’åº
- åˆ—å‡ºTop 10é«˜ä¼˜ä»»åŠ¡ï¼ˆé‡è¦åº¦>=8ï¼‰
- ç”¨è¡¨æ ¼å±•ç¤ºï¼šæ—¥æœŸã€ä»»åŠ¡å†…å®¹ã€é‡è¦åº¦ã€çŠ¶æ€ã€åˆ†ç±»
- æ ‡æ³¨ç´§æ€¥ç¨‹åº¦å’Œå»ºè®®å¤„ç†é¡ºåº

## â° 2. æ—¶é—´åˆ†é…åˆç†æ€§åˆ†æ
- åˆ†æå·¥ä½œã€å­¦ä¹ ã€ç”Ÿæ´»å„ç±»ä»»åŠ¡çš„æ—¶é—´å æ¯”
- ç”¨é¥¼å›¾æ•°æ®å±•ç¤ºåˆ†ç±»åˆ†å¸ƒ
- è¯„ä¼°æ—¶é—´åˆ†é…æ˜¯å¦åˆç†ï¼Œæ˜¯å¦æœ‰å¤±è¡¡ç°è±¡
- æä¾›å…·ä½“çš„æ—¶é—´åˆ†é…å»ºè®®ï¼ˆå¦‚å·¥ä½œ50%ã€å­¦ä¹ 30%ã€ç”Ÿæ´»20%ï¼‰

## âš ï¸ 3. ä»»åŠ¡å†²çªä¸é£é™©æ£€æµ‹
- æ ‡æ³¨åŒä¸€å¤©å†…æœ‰å¤šä¸ªé«˜ä¼˜ä»»åŠ¡ï¼ˆimportance>=8ï¼‰çš„æ—¥æœŸ
- ç”¨è¡¨æ ¼åˆ—å‡ºå†²çªæ—¥æœŸã€ä»»åŠ¡æ•°é‡ã€ä»»åŠ¡åˆ—è¡¨
- åˆ†æå¯èƒ½çš„æ—¶é—´å†²çªå’Œèµ„æºå†²çª
- æä¾›è§£å†³æ–¹æ¡ˆï¼ˆå¦‚ä»»åŠ¡é‡æ’ã€ä¼˜å…ˆçº§è°ƒæ•´ï¼‰

## ğŸ“ˆ 4. å®Œæˆè¿›åº¦ä¸æ•ˆç‡æ€»ç»“
- ç»Ÿè®¡å®Œæˆç‡ï¼ˆå·²å®Œæˆ/æ€»æ•°ï¼‰
- åˆ†æå„åˆ†ç±»çš„å®Œæˆæƒ…å†µ
- è¯†åˆ«æ‹–å»¶é£é™©é«˜çš„ä»»åŠ¡ï¼ˆæœªå¼€å§‹ä¸”ä¸´è¿‘æ—¥æœŸï¼‰
- è¯„ä¼°æ•´ä½“æ‰§è¡Œæ•ˆç‡

## ğŸ’¡ 5. ä¼˜åŒ–å»ºè®®ä¸è¡ŒåŠ¨è®¡åˆ’
- æä¾›3-5æ¡å…·ä½“å¯æ‰§è¡Œçš„æ”¹è¿›å»ºè®®
- é’ˆå¯¹å‘ç°çš„é—®é¢˜ç»™å‡ºè§£å†³æ–¹æ¡ˆ
- å»ºè®®ä»»åŠ¡é‡æ’åºæˆ–æ—¶é—´è°ƒæ•´
- æä¾›æ—¶é—´ç®¡ç†æŠ€å·§ï¼ˆå¦‚ç•ªèŒ„å·¥ä½œæ³•ã€æ—¶é—´å—ï¼‰

**æ³¨æ„äº‹é¡¹ï¼š**
- ä¿æŒä¸“ä¸šã€å®¢è§‚ã€å®ç”¨
- é¿å…æ³›æ³›è€Œè°ˆï¼Œæä¾›å¯é‡åŒ–çš„å»ºè®®
- ç”¨æ•°æ®æ”¯æ’‘è§‚ç‚¹
- è¯­è¨€ç®€æ´æ˜äº†ï¼Œæ˜“äºç†è§£
- é€‚å½“ä½¿ç”¨emojiå¢å¼ºå¯è¯»æ€§`;

    return prompt;
  }

  /**
   * æ‰§è¡ŒAIåˆ†æ
   */
  static async performAnalysis(userId, options) {
    const transaction = await require('../database/connection').beginTransaction();
    
    try {
      const {
        scan_days = 15,
        model_id,
        focus_areas = ['priority', 'time_allocation', 'conflicts', 'progress', 'optimization']
      } = options;

      // 1. éªŒè¯ç”¨æˆ·
      const user = await User.findById(userId);
      if (!user) {
        throw new ValidationError('ç”¨æˆ·ä¸å­˜åœ¨');
      }

      // 2. éªŒè¯å¹¶è·å–AIæ¨¡å‹
      const model = await AIModel.findById(model_id);
      if (!model) {
        throw new ValidationError('AIæ¨¡å‹ä¸å­˜åœ¨');
      }

      if (!model.is_active) {
        throw new ValidationError('è¯¥AIæ¨¡å‹å·²ç¦ç”¨');
      }

      // 3. è®¡ç®—æ—¥æœŸèŒƒå›´
      const today = new Date();
      const scanDateStart = new Date(today);
      scanDateStart.setDate(today.getDate() - scan_days);
      const scanDateEnd = new Date(today);
      scanDateEnd.setDate(today.getDate() + scan_days);

      const formatDate = (date) => date.toISOString().split('T')[0];

      // 4. è·å–äº‹é¡¹æ•°æ®
      const { events } = await CalendarEvent.getUserEvents(userId, {
        start_date: formatDate(scanDateStart),
        end_date: formatDate(scanDateEnd),
        limit: 1000
      });

      if (events.length === 0) {
        throw new ValidationError('è¯¥æ—¶é—´èŒƒå›´å†…æ²¡æœ‰äº‹é¡¹ï¼Œæ— éœ€åˆ†æ');
      }

      // 5. è®¡ç®—éœ€è¦æ¶ˆè€—çš„ç§¯åˆ†
      const totalScanDays = scan_days * 2; // å‰åå„Nå¤©
      const creditsNeeded = CalendarService.calculateAnalysisCredits(
        totalScanDays, 
        model.credits_per_chat || 10
      );

      // 6. æ£€æŸ¥å¹¶æ‰£é™¤ç§¯åˆ†ï¼ˆä½¿ç”¨äº‹åŠ¡ï¼‰
      if (!user.hasCredits(creditsNeeded)) {
        throw new ValidationError(`ç§¯åˆ†ä¸è¶³ï¼Œéœ€è¦${creditsNeeded}ç§¯åˆ†ï¼Œå½“å‰ä½™é¢${user.getCredits()}ç§¯åˆ†`);
      }

      // 7. æ„å»ºPrompt
      const prompt = CalendarService.buildAnalysisPrompt(
        events,
        formatDate(scanDateStart),
        formatDate(scanDateEnd)
      );

      // 8. è°ƒç”¨AIæœåŠ¡
      let analysisText = '';
      
      if (model.provider === 'anthropic') {
        analysisText = await AnthropicService.chat({
          model: model.name,
          prompt,
          max_tokens: 4096,
          temperature: 0.7
        });
      } else if (model.provider === 'openai') {
        analysisText = await OpenAIService.chat({
          model: model.name,
          messages: [{ role: 'user', content: prompt }],
          max_tokens: 4096,
          temperature: 0.7
        });
      } else {
        throw new ValidationError('ä¸æ”¯æŒçš„AIæä¾›å•†');
      }

      // 9. æ‰£é™¤ç§¯åˆ†
      await user.consumeCredits(
        creditsNeeded,
        model_id,
        null,
        `æ—¥å†AIåˆ†æ - ${events.length}ä¸ªäº‹é¡¹ - ${model.display_name}`,
        'calendar_ai_analysis'
      );

      // 10. ä¿å­˜åˆ†æç»“æœ
      const analysisData = {
        scan_date_start: formatDate(scanDateStart),
        scan_date_end: formatDate(scanDateEnd),
        model_id: model.id,
        model_name: model.display_name,
        analysis_result: {
          raw_text: analysisText,
          events_analyzed: events.length,
          scan_range_days: totalScanDays,
          focus_areas,
          generated_at: new Date().toISOString()
        },
        credits_consumed: creditsNeeded,
        events_count: events.length
      };

      const analysis = await CalendarAIAnalysis.create(analysisData, userId);

      await transaction.commit();

      logger.info('æ—¥å†AIåˆ†æå®Œæˆ', {
        userId,
        analysisId: analysis.id,
        eventsCount: events.length,
        creditsConsumed: creditsNeeded,
        modelName: model.display_name
      });

      return {
        analysis: analysis.toJSON(),
        balance_after: user.getCredits() - creditsNeeded
      };

    } catch (error) {
      await transaction.rollback();
      logger.error('æ—¥å†AIåˆ†æå¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * éªŒè¯åˆ†æå‚æ•°
   */
  static validateAnalysisParams(params) {
    const { scan_days, model_id } = params;

    if (!model_id) {
      throw new ValidationError('è¯·é€‰æ‹©AIæ¨¡å‹');
    }

    if (scan_days < 1 || scan_days > 180) {
      throw new ValidationError('æ‰«æèŒƒå›´å¿…é¡»åœ¨1-180å¤©ä¹‹é—´');
    }

    return true;
  }
}

module.exports = CalendarService;

/**
 * AI Platform ä¸»åº”ç”¨å…¥å£ - æ”¯æŒWebSocketå’ŒåŠ¨æ€æ¨¡å—ä»£ç†
 */

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const compression = require('compression');
const cookieParser = require('cookie-parser');
const path = require('path');
const { createServer } = require('http');
const { Server } = require('socket.io');

// å¯¼å…¥é…ç½®å’Œå·¥å…·
const config = require('./config');
const logger = require('./utils/logger');
const dbConnection = require('./database/connection');
const redisConnection = require('./database/redis');
const StatsService = require('./services/statsService');

// å¯¼å…¥è·¯ç”±
const authRoutes = require('./routes/auth');
const chatRoutes = require('./routes/chat');
const adminRoutes = require('./routes/admin');
const statsRoutes = require('./routes/stats');

// å¯¼å…¥åŠ¨æ€æ¨¡å—ä»£ç†ç®¡ç†å™¨
const moduleProxyManager = require('./middleware/moduleProxy');

// å¯¼å…¥è®¤è¯ä¸­é—´ä»¶ç”¨äºSocket.IO
const jwt = require('jsonwebtoken');
const User = require('./models/User');

class App {
  constructor() {
    this.app = express();
    this.server = null;
    this.io = null;
    this.onlineUsers = new Map(); // userId -> socketId
  }

  /**
   * åˆå§‹åŒ–åº”ç”¨
   */
  async initialize() {
    try {
      logger.info('å¼€å§‹åˆå§‹åŒ–AI Platformåº”ç”¨...');

      // åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
      await this.initializeDatabase();
      
      // åˆå§‹åŒ–Redisè¿æ¥
      await this.initializeRedis();

      // é…ç½®Expressä¸­é—´ä»¶
      this.setupMiddleware();

      // é…ç½®è·¯ç”±
      this.setupRoutes();

      // åˆå§‹åŒ–åŠ¨æ€æ¨¡å—ä»£ç†
      await this.initializeModuleProxy();

      // é…ç½®é”™è¯¯å¤„ç†
      this.setupErrorHandling();

      // åˆ›å»ºHTTPæœåŠ¡å™¨
      this.server = createServer(this.app);

      // åˆå§‹åŒ–Socket.IO
      this.initializeSocketIO();

      // å¯åŠ¨å®šæ—¶ä»»åŠ¡
      this.startScheduledTasks();

      logger.info('AI Platformåº”ç”¨åˆå§‹åŒ–å®Œæˆ');
    } catch (error) {
      logger.error('åº”ç”¨åˆå§‹åŒ–å¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
   */
  async initializeDatabase() {
    try {
      await dbConnection.initialize();
      logger.info('æ•°æ®åº“è¿æ¥åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      logger.error('æ•°æ®åº“è¿æ¥åˆå§‹åŒ–å¤±è´¥:', error);
      throw error;
    }
  }
  
  /**
   * åˆå§‹åŒ–Redisè¿æ¥
   */
  async initializeRedis() {
    try {
      await redisConnection.initialize();
      logger.info('Redisè¿æ¥åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      logger.error('Redisè¿æ¥åˆå§‹åŒ–å¤±è´¥:', error);
      // Rediså¤±è´¥ä¸å½±å“ä¸»æœåŠ¡ï¼Œä»…è®°å½•è­¦å‘Š
      logger.warn('åº”ç”¨å°†åœ¨æ— Redisç¼“å­˜çš„æƒ…å†µä¸‹è¿è¡Œ');
    }
  }

  /**
   * åˆå§‹åŒ–åŠ¨æ€æ¨¡å—ä»£ç†
   */
  async initializeModuleProxy() {
    try {
      await moduleProxyManager.initialize(this.app);
      logger.info('åŠ¨æ€æ¨¡å—ä»£ç†åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      logger.error('åŠ¨æ€æ¨¡å—ä»£ç†åˆå§‹åŒ–å¤±è´¥:', error);
      // ä»£ç†å¤±è´¥ä¸å½±å“ä¸»æœåŠ¡ï¼Œä»…è®°å½•è­¦å‘Š
      logger.warn('åº”ç”¨å°†åœ¨æ— åŠ¨æ€æ¨¡å—ä»£ç†çš„æƒ…å†µä¸‹è¿è¡Œ');
    }
  }

  /**
   * åˆå§‹åŒ–Socket.IO
   */
  initializeSocketIO() {
    this.io = new Server(this.server, {
      cors: config.security.cors,
      path: '/socket.io/',
      transports: ['websocket', 'polling']
    });

    // Socket.IOè®¤è¯ä¸­é—´ä»¶
    this.io.use(async (socket, next) => {
      try {
        const token = socket.handshake.auth.token || socket.handshake.query.token;
        
        if (!token) {
          return next(new Error('Authentication error: No token'));
        }

        const decoded = jwt.verify(token, config.auth.jwt.accessSecret);
        
        if (decoded.type !== 'access') {
          return next(new Error('Authentication error: Invalid token type'));
        }

        const user = await User.findById(decoded.userId);
        if (!user || user.status !== 'active') {
          return next(new Error('Authentication error: User not found or inactive'));
        }

        socket.userId = user.id;
        socket.user = user;
        next();
      } catch (err) {
        logger.error('Socket.IOè®¤è¯å¤±è´¥:', err);
        next(new Error('Authentication error'));
      }
    });

    // Socket.IOè¿æ¥å¤„ç†
    this.io.on('connection', (socket) => {
      const userId = socket.userId;
      
      logger.info('ç”¨æˆ·WebSocketè¿æ¥', { userId, socketId: socket.id });
      
      // è®°å½•åœ¨çº¿ç”¨æˆ·
      this.onlineUsers.set(userId, socket.id);
      
      // æ›´æ–°åœ¨çº¿çŠ¶æ€
      StatsService.updateUserOnlineStatus(userId, true);
      
      // åŠ å…¥ç”¨æˆ·æˆ¿é—´
      socket.join(`user:${userId}`);
      
      // å¹¿æ’­åœ¨çº¿ç”¨æˆ·æ•°æ›´æ–°
      this.broadcastOnlineCount();

      // å¤„ç†æ–­å¼€è¿æ¥
      socket.on('disconnect', () => {
        logger.info('ç”¨æˆ·WebSocketæ–­å¼€', { userId, socketId: socket.id });
        
        this.onlineUsers.delete(userId);
        StatsService.updateUserOnlineStatus(userId, false);
        
        // å¹¿æ’­åœ¨çº¿ç”¨æˆ·æ•°æ›´æ–°
        this.broadcastOnlineCount();
      });

      // å¤„ç†å¿ƒè·³
      socket.on('heartbeat', () => {
        StatsService.updateUserOnlineStatus(userId, true);
        socket.emit('heartbeat:ack', { timestamp: new Date().toISOString() });
      });

      // å¤„ç†è·å–ç»Ÿè®¡æ•°æ®è¯·æ±‚
      socket.on('stats:get', async () => {
        const stats = await StatsService.getRealtimeStats();
        socket.emit('stats:update', stats);
      });
    });

    logger.info('Socket.IOåˆå§‹åŒ–å®Œæˆ');
  }

  /**
   * å¹¿æ’­åœ¨çº¿ç”¨æˆ·æ•°
   */
  async broadcastOnlineCount() {
    const count = await StatsService.getOnlineCount();
    this.io.emit('online:count', { count });
  }

  /**
   * å¹¿æ’­å®æ—¶ç»Ÿè®¡æ›´æ–°
   */
  async broadcastStatsUpdate() {
    const stats = await StatsService.getRealtimeStats();
    this.io.emit('stats:update', stats);
  }

  /**
   * å¯åŠ¨å®šæ—¶ä»»åŠ¡
   */
  startScheduledTasks() {
    // æ¯30ç§’å¹¿æ’­ä¸€æ¬¡ç»Ÿè®¡æ•°æ®
    setInterval(() => {
      this.broadcastStatsUpdate();
    }, 30000);

    // æ¯åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡è¿‡æœŸçš„åœ¨çº¿çŠ¶æ€
    setInterval(() => {
      StatsService.cleanupExpiredOnlineStatus();
    }, 60000);

    logger.info('å®šæ—¶ä»»åŠ¡å¯åŠ¨å®Œæˆ');
  }

  /**
   * é…ç½®Expressä¸­é—´ä»¶
   */
  setupMiddleware() {
    // ä¿¡ä»»ä»£ç†
    this.app.set('trust proxy', 1);

    // å®‰å…¨å¤´éƒ¨ä¸­é—´ä»¶
    this.app.use(helmet(config.security.helmet));

    // CORSè·¨åŸŸä¸­é—´ä»¶
    this.app.use(cors(config.security.cors));

    // Gzipå‹ç¼©ä¸­é—´ä»¶
    this.app.use(compression());

    // Cookieè§£æä¸­é—´ä»¶
    this.app.use(cookieParser());

    // JSONè§£æä¸­é—´ä»¶
    this.app.use(express.json({ limit: '10mb' }));

    // URLç¼–ç è§£æä¸­é—´ä»¶
    this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));

    // HTTPè¯·æ±‚æ—¥å¿—
    this.app.use(morgan('combined', {
      stream: logger.stream,
      skip: (req, res) => req.url === '/health' || req.url === '/favicon.ico'
    }));

    logger.info('Expressä¸­é—´ä»¶é…ç½®å®Œæˆ');
  }

  /**
   * é…ç½®è·¯ç”±
   */
  setupRoutes() {
    // å¥åº·æ£€æŸ¥æ¥å£
    this.app.get('/health', (req, res) => {
      const dbStatus = dbConnection.getStatus();
      const redisStatus = redisConnection.getStatus();
      
      res.json({
        success: true,
        message: 'AI PlatformæœåŠ¡è¿è¡Œæ­£å¸¸',
        data: {
          timestamp: new Date().toISOString(),
          environment: config.app.env,
          version: config.app.version,
          database: dbStatus,
          redis: redisStatus,
          websocket: this.io ? 'connected' : 'disconnected',
          onlineUsers: this.onlineUsers.size,
          memory: process.memoryUsage(),
          uptime: process.uptime()
        }
      });
    });

    // APIæ ¹è·¯å¾„ä¿¡æ¯
    this.app.get('/api', (req, res) => {
      res.json({
        success: true,
        message: 'AI Platform API',
        data: {
          name: config.app.name,
          version: config.app.version,
          environment: config.app.env,
          timestamp: new Date().toISOString()
        }
      });
    });

    // è®¤è¯ç›¸å…³è·¯ç”±
    this.app.use('/api/auth', authRoutes);
    
    // AIå¯¹è¯ç›¸å…³è·¯ç”±
    this.app.use('/api/chat', chatRoutes);
    
    // ç®¡ç†å‘˜ç›¸å…³è·¯ç”±
    this.app.use('/api/admin', adminRoutes);
    
    // ç»Ÿè®¡ç›¸å…³è·¯ç”±
    this.app.use('/api/stats', statsRoutes);

    // æ¨¡å—ä»£ç†ä¿¡æ¯æ¥å£ï¼ˆè°ƒè¯•ç”¨ï¼‰
    this.app.get('/api/admin/proxy-info', (req, res) => {
      const proxyInfo = moduleProxyManager.getProxyInfo();
      res.json({
        success: true,
        message: 'è·å–ä»£ç†ä¿¡æ¯æˆåŠŸ',
        data: proxyInfo
      });
    });

    logger.info('è·¯ç”±é…ç½®å®Œæˆ');
  }

  /**
   * é…ç½®é”™è¯¯å¤„ç†
   */
  setupErrorHandling() {
    // 404é”™è¯¯å¤„ç†
    this.app.use((req, res, next) => {
      res.status(404).json({
        success: false,
        code: 404,
        message: 'è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨',
        data: null,
        timestamp: new Date().toISOString()
      });
    });

    // å…¨å±€é”™è¯¯å¤„ç†
    this.app.use((err, req, res, next) => {
      logger.error('å…¨å±€é”™è¯¯å¤„ç†:', err);
      
      res.status(err.status || 500).json({
        success: false,
        code: err.status || 500,
        message: err.message || 'å†…éƒ¨æœåŠ¡å™¨é”™è¯¯',
        data: null,
        timestamp: new Date().toISOString()
      });
    });

    logger.info('é”™è¯¯å¤„ç†é…ç½®å®Œæˆ');
  }

  /**
   * å¯åŠ¨æœåŠ¡å™¨
   */
  async start() {
    try {
      const port = config.app.port;
      
      this.server.listen(port, () => {
        logger.info(`AI PlatformæœåŠ¡å™¨å¯åŠ¨æˆåŠŸ - ç«¯å£:${port}`);
        
        console.log(`
ğŸš€ AI Platform æœåŠ¡å™¨å¯åŠ¨æˆåŠŸ!
ğŸ“¡ ç«¯å£: ${port}
ğŸŒ åŸŸå: ${config.app.domain}
ğŸ”§ ç¯å¢ƒ: ${config.app.env}
ğŸ“‹ è¿›ç¨‹ID: ${process.pid}
â° å¯åŠ¨æ—¶é—´: ${new Date().toLocaleString()}
ğŸ”Œ WebSocket: å·²å¯ç”¨
ğŸ”€ åŠ¨æ€ä»£ç†: å·²å¯ç”¨

APIåœ°å€: http://localhost:${port}/api
å¥åº·æ£€æŸ¥: http://localhost:${port}/health
WebSocket: ws://localhost:${port}/socket.io/
ä»£ç†ä¿¡æ¯: http://localhost:${port}/api/admin/proxy-info
        `);
      });

      // å¤„ç†æœåŠ¡å™¨é”™è¯¯
      this.server.on('error', (error) => {
        if (error.code === 'EADDRINUSE') {
          logger.error(`ç«¯å£ ${port} å·²è¢«å ç”¨`);
        } else {
          logger.error('æœåŠ¡å™¨å¯åŠ¨å¤±è´¥:', error);
        }
        process.exit(1);
      });

      // ä¼˜é›…å…³é—­å¤„ç†
      process.on('SIGTERM', async () => {
        logger.info('æ”¶åˆ°SIGTERMä¿¡å·ï¼Œå¼€å§‹ä¼˜é›…å…³é—­...');
        await this.gracefulShutdown();
      });

      process.on('SIGINT', async () => {
        logger.info('æ”¶åˆ°SIGINTä¿¡å·ï¼Œå¼€å§‹ä¼˜é›…å…³é—­...');
        await this.gracefulShutdown();
      });

    } catch (error) {
      logger.error('å¯åŠ¨æœåŠ¡å™¨å¤±è´¥:', error);
      process.exit(1);
    }
  }
  
  /**
   * ä¼˜é›…å…³é—­
   */
  async gracefulShutdown() {
    try {
      // å…³é—­Socket.IO
      if (this.io) {
        this.io.close();
      }

      // å…³é—­HTTPæœåŠ¡å™¨
      if (this.server) {
        this.server.close();
      }
      
      // å…³é—­æ•°æ®åº“è¿æ¥
      await dbConnection.close();
      
      // å…³é—­Redisè¿æ¥
      await redisConnection.close();
      
      logger.info('æœåŠ¡å™¨å·²ä¼˜é›…å…³é—­');
      process.exit(0);
    } catch (error) {
      logger.error('ä¼˜é›…å…³é—­å¤±è´¥:', error);
      process.exit(1);
    }
  }

  /**
   * è·å–Socket.IOå®ä¾‹ï¼ˆä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ï¼‰
   */
  getIO() {
    return this.io;
  }

  /**
   * è·å–Expressåº”ç”¨å®ä¾‹ï¼ˆä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ï¼‰
   */
  getApp() {
    return this.app;
  }
}

// åˆ›å»ºå¹¶å¯åŠ¨åº”ç”¨
async function bootstrap() {
  const app = new App();
  
  try {
    await app.initialize();
    await app.start();
    
    // å¯¼å‡ºappå®ä¾‹ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨
    module.exports.appInstance = app;
  } catch (error) {
    logger.error('åº”ç”¨å¯åŠ¨å¤±è´¥:', error);
    process.exit(1);
  }
}

// å¦‚æœç›´æ¥è¿è¡Œæ­¤æ–‡ä»¶ï¼Œåˆ™å¯åŠ¨åº”ç”¨
if (require.main === module) {
  bootstrap();
}

module.exports = App;

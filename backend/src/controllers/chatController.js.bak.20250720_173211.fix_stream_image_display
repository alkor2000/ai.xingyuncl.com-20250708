/**
 * 对话控制器 - 集成积分扣减系统、动态上下文、流式输出、缓存、优先级排序和图片上传
 */

const { v4: uuidv4 } = require('uuid');
const Conversation = require('../models/Conversation');
const Message = require('../models/Message');
const File = require('../models/File');
const AIService = require('../services/aiService');
const AIStreamService = require('../services/aiStreamService');
const CacheService = require('../services/cacheService');
const StatsService = require('../services/statsService');
const User = require('../models/User');
const AIModel = require('../models/AIModel');
const ResponseHelper = require('../utils/response');
const logger = require('../utils/logger');
const { ValidationError, AuthorizationError, NotFoundError } = require('../utils/errors');
const { getFileUrl } = require('../middleware/uploadMiddleware');

class ChatController {
  /**
   * 获取用户的会话列表
   * GET /api/chat/conversations
   */
  static async getConversations(req, res) {
    try {
      const userId = req.user.id;
      const { page = 1, limit = 20 } = req.query;

      logger.info('获取用户会话列表', { userId, page, limit });

      const result = await Conversation.getUserConversations(userId, {
        page: parseInt(page),
        limit: parseInt(limit)
      });

      return ResponseHelper.paginated(res, result.conversations, result.pagination, '获取会话列表成功');
    } catch (error) {
      logger.error('获取会话列表失败', { 
        userId: req.user?.id, 
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, '获取会话列表失败');
    }
  }

  /**
   * 创建新会话 - 支持上下文数量、temperature设置和优先级
   * POST /api/chat/conversations
   */
  static async createConversation(req, res) {
    try {
      const userId = req.user.id;
      const { title, model_name, system_prompt, context_length, ai_temperature, priority } = req.body;

      logger.info('开始创建会话', { 
        userId, 
        title, 
        model_name, 
        context_length,
        ai_temperature,
        priority,
        hasSystemPrompt: !!system_prompt 
      });

      // 验证模型名称
      if (!model_name) {
        return ResponseHelper.validation(res, ['模型名称不能为空']);
      }

      // 验证AI模型是否存在且启用
      const aiModel = await AIModel.findByName(model_name);
      if (!aiModel || !aiModel.is_active) {
        return ResponseHelper.validation(res, ['选择的AI模型不可用']);
      }

      // 检查用户是否有权限使用该模型（考虑用户限制）
      const userGroupId = req.user.group_id;
      const availableModels = await AIModel.getUserAvailableModels(userId, userGroupId);
      const canUseModel = availableModels.some(m => m.name === model_name);
      
      if (!canUseModel) {
        return ResponseHelper.forbidden(res, '您无权使用该模型');
      }

      // 验证上下文数量
      let validContextLength = parseInt(context_length) || 20;
      if (validContextLength < 0) validContextLength = 0;
      if (validContextLength > 1000) validContextLength = 1000;

      // 验证temperature参数
      let validTemperature = parseFloat(ai_temperature);
      if (isNaN(validTemperature)) validTemperature = 0.0;
      if (validTemperature < 0.0) validTemperature = 0.0;
      if (validTemperature > 1.0) validTemperature = 1.0;

      const conversationData = {
        user_id: parseInt(userId),
        title: title || 'New Chat',
        model_name: model_name || 'gpt-3.5-turbo',
        system_prompt: system_prompt || null,
        context_length: validContextLength,
        ai_temperature: validTemperature,
        priority: parseInt(priority) || 0
      };

      logger.info('会话数据准备完成', conversationData);

      const conversation = await Conversation.create(conversationData);

      logger.info('会话创建成功', { 
        userId, 
        conversationId: conversation.id,
        modelName: conversation.model_name,
        contextLength: conversation.context_length,
        aiTemperature: conversation.ai_temperature,
        priority: conversation.priority
      });

      return ResponseHelper.success(res, conversation.toJSON(), '会话创建成功', 201);
    } catch (error) {
      logger.error('会话创建失败', { 
        userId: req.user?.id, 
        requestBody: req.body,
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, `会话创建失败: ${error.message}`);
    }
  }

  /**
   * 获取会话详情
   * GET /api/chat/conversations/:id
   */
  static async getConversation(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;

      // 检查会话所有权
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, '无权访问此会话');
      }

      const conversation = await Conversation.findById(id);
      if (!conversation) {
        return ResponseHelper.notFound(res, '会话不存在');
      }

      // 检查是否有草稿
      const draft = await CacheService.getDraft(userId, id);
      const responseData = conversation.toJSON();
      if (draft) {
        responseData.draft = draft;
      }

      return ResponseHelper.success(res, responseData, '获取会话成功');
    } catch (error) {
      logger.error('获取会话详情失败', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, '获取会话失败');
    }
  }

  /**
   * 更新会话 - 支持上下文数量、temperature和优先级更新
   * PUT /api/chat/conversations/:id
   */
  static async updateConversation(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const { title, model_name, system_prompt, is_pinned, context_length, ai_temperature, priority } = req.body;

      // 检查会话所有权
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, '无权修改此会话');
      }

      const conversation = await Conversation.findById(id);
      if (!conversation) {
        return ResponseHelper.notFound(res, '会话不存在');
      }

      // 如果更换模型，验证新模型
      if (model_name && model_name !== conversation.model_name) {
        const aiModel = await AIModel.findByName(model_name);
        if (!aiModel || !aiModel.is_active) {
          return ResponseHelper.validation(res, ['选择的AI模型不可用']);
        }

        // 检查用户是否有权限使用该模型（考虑用户限制）
        const userGroupId = req.user.group_id;
        const availableModels = await AIModel.getUserAvailableModels(userId, userGroupId);
        const canUseModel = availableModels.some(m => m.name === model_name);
        
        if (!canUseModel) {
          return ResponseHelper.forbidden(res, '您无权使用该模型');
        }
      }

      // 验证上下文数量
      let updateData = { title, model_name, system_prompt, is_pinned };
      
      if (context_length !== undefined) {
        let validContextLength = parseInt(context_length) || 20;
        if (validContextLength < 0) validContextLength = 0;
        if (validContextLength > 1000) validContextLength = 1000;
        updateData.context_length = validContextLength;
      }

      // 验证temperature参数
      if (ai_temperature !== undefined) {
        let validTemperature = parseFloat(ai_temperature);
        if (isNaN(validTemperature)) validTemperature = 0.0;
        if (validTemperature < 0.0) validTemperature = 0.0;
        if (validTemperature > 1.0) validTemperature = 1.0;
        updateData.ai_temperature = validTemperature;
      }

      // 验证优先级
      if (priority !== undefined) {
        updateData.priority = parseInt(priority) || 0;
      }

      const updatedConversation = await conversation.update(updateData);

      logger.info('会话更新成功', { 
        userId, 
        conversationId: id,
        updateData
      });

      return ResponseHelper.success(res, updatedConversation.toJSON(), '会话更新成功');
    } catch (error) {
      logger.error('会话更新失败', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, '会话更新失败');
    }
  }

  /**
   * 删除会话
   * DELETE /api/chat/conversations/:id
   */
  static async deleteConversation(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;

      // 检查会话所有权
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, '无权删除此会话');
      }

      const conversation = await Conversation.findById(id);
      if (!conversation) {
        return ResponseHelper.notFound(res, '会话不存在');
      }

      await conversation.delete();

      // 清除相关缓存
      await CacheService.clearConversationCache(userId, id);

      logger.info('会话删除成功', { 
        userId, 
        conversationId: id 
      });

      return ResponseHelper.success(res, null, '会话删除成功');
    } catch (error) {
      logger.error('会话删除失败', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, '会话删除失败');
    }
  }

  /**
   * 获取会话消息
   * GET /api/chat/conversations/:id/messages
   */
  static async getMessages(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const { page = 1, limit = 50, useCache = true } = req.query;

      // 检查会话所有权
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, '无权访问此会话消息');
      }

      // 尝试从缓存获取
      if (useCache !== 'false') {
        const cachedMessages = await CacheService.getCachedMessages(userId, id);
        if (cachedMessages) {
          logger.info('从缓存返回消息', { conversationId: id, count: cachedMessages.length });
          
          // 处理带图片的消息
          const messagesWithFiles = await Promise.all(cachedMessages.map(async msg => {
            if (msg.file_id) {
              const file = await File.findById(msg.file_id);
              if (file) {
                msg.file = file.toJSON();
              }
            }
            return msg;
          }));
          
          return ResponseHelper.success(res, messagesWithFiles, '获取消息列表成功');
        }
      }

      // 从数据库获取
      const result = await Message.getConversationMessages(id, {
        page: parseInt(page),
        limit: parseInt(limit),
        order: 'ASC'
      });

      // 处理带图片的消息
      const messagesWithFiles = await Promise.all(result.messages.map(async msg => {
        const msgData = msg.toJSON();
        if (msgData.file_id) {
          const file = await File.findById(msgData.file_id);
          if (file) {
            msgData.file = file.toJSON();
          }
        }
        return msgData;
      }));

      // 缓存消息（只缓存第一页）
      if (page == 1 && messagesWithFiles.length > 0) {
        await CacheService.cacheMessages(userId, id, messagesWithFiles);
      }

      return ResponseHelper.paginated(res, messagesWithFiles, result.pagination, '获取消息列表成功');
    } catch (error) {
      logger.error('获取会话消息失败', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, '获取消息失败');
    }
  }

  /**
   * 上传图片
   * POST /api/chat/upload-image
   */
  static async uploadImage(req, res) {
    try {
      const userId = req.user.id;
      
      if (!req.file) {
        return ResponseHelper.validation(res, ['请选择要上传的图片']);
      }
      
      const { filename, originalname, mimetype, size, path: filePath } = req.file;
      
      // 创建文件记录
      const file = await File.create({
        user_id: userId,
        filename: filename,
        original_name: originalname,
        mime_type: mimetype,
        size: size,
        path: filePath,
        url: getFileUrl(filePath)
      });
      
      logger.info('图片上传成功', {
        userId,
        fileId: file.id,
        filename
      });
      
      return ResponseHelper.success(res, file.toJSON(), '图片上传成功');
    } catch (error) {
      logger.error('图片上传失败', {
        userId: req.user?.id,
        error: error.message
      });
      return ResponseHelper.error(res, '图片上传失败');
    }
  }

  /**
   * 发送消息并获取AI回复 - 统一处理流式和非流式（支持图片）
   * POST /api/chat/conversations/:id/messages
   */
  static async sendMessage(req, res) {
    let creditsConsumed = 0;
    let conversationBackup = null;
    let userMessage = null;
    
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const { content, file_id, stream = false } = req.body;

      if (!content || content.trim().length === 0) {
        return ResponseHelper.validation(res, ['消息内容不能为空']);
      }

      // 检查会话所有权
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, '无权在此会话中发送消息');
      }

      const conversation = await Conversation.findById(id);
      if (!conversation) {
        return ResponseHelper.notFound(res, '会话不存在');
      }

      // 获取AI模型积分配置
      const aiModel = await AIModel.findByName(conversation.model_name);
      if (!aiModel || !aiModel.is_active) {
        return ResponseHelper.error(res, '当前AI模型不可用');
      }

      // 检查用户是否有权限使用该模型（考虑用户限制）
      const userGroupId = req.user.group_id;
      const availableModels = await AIModel.getUserAvailableModels(userId, userGroupId);
      const canUseModel = availableModels.some(m => m.name === conversation.model_name);
      
      if (!canUseModel) {
        return ResponseHelper.forbidden(res, '您已被限制使用该模型，请创建新会话选择其他模型');
      }

      // 如果有图片，检查模型是否支持
      if (file_id) {
        if (!aiModel.image_upload_enabled) {
          return ResponseHelper.validation(res, ['当前AI模型不支持图片识别']);
        }
        
        // 验证文件所有权
        const fileOwnership = await File.checkOwnership(file_id, userId);
        if (!fileOwnership) {
          return ResponseHelper.forbidden(res, '无权使用此文件');
        }
      }

      // 判断是否使用流式输出
      const useStream = stream && aiModel.stream_enabled;

      const requiredCredits = aiModel.credits_per_chat || 10;
      
      // 检查用户积分余额
      const user = await User.findById(userId);
      if (!user.hasCredits(requiredCredits)) {
        return ResponseHelper.forbidden(res, `积分不足，需要 ${requiredCredits} 积分，当前余额 ${user.getCredits()} 积分`);
      }

      // 检查用户Token配额
      const estimatedTokens = Message.estimateTokens(content);
      if (!user.hasTokenQuota(estimatedTokens * 2)) {
        return ResponseHelper.forbidden(res, 'Token配额不足');
      }

      // 清除草稿（用户已发送）
      await CacheService.deleteDraft(userId, id);

      // 备份对话状态
      conversationBackup = {
        message_count: conversation.message_count,
        total_tokens: conversation.total_tokens
      };

      logger.info('预扣减积分开始', {
        userId,
        conversationId: id,
        modelName: conversation.model_name,
        useStream,
        requiredCredits,
        currentBalance: user.getCredits(),
        hasImage: !!file_id
      });

      // 预先扣减积分
      const creditsResult = await user.consumeCredits(
        requiredCredits, 
        aiModel.id, 
        id, 
        `AI对话消费 - ${aiModel.display_name}`
      );
      
      creditsConsumed = requiredCredits;

      // 创建用户消息
      userMessage = await Message.create({
        conversation_id: id,
        role: 'user',
        content: content.trim(),
        tokens: estimatedTokens,
        file_id
      });

      // 获取会话历史消息
      const recentMessages = await Message.getRecentMessages(id);
      
      // 构造AI请求消息（包含图片）
      const aiMessages = [];
      
      if (conversation.system_prompt) {
        aiMessages.push({
          role: 'system',
          content: conversation.system_prompt
        });
      }
      
      for (const msg of recentMessages) {
        const aiMsg = msg.toAIFormat();
        
        // 如果消息有图片，添加图片信息
        if (msg.file_id && aiModel.image_upload_enabled) {
          const file = await File.findById(msg.file_id);
          if (file) {
            aiMsg.image_url = file.url;
          }
        }
        
        aiMessages.push(aiMsg);
      }

      logger.info('发送AI请求', { 
        userId,
        conversationId: id,
        modelName: conversation.model_name,
        useStream,
        messageCount: aiMessages.length,
        hasImage: !!file_id
      });

      // 处理流式或非流式响应
      if (useStream) {
        // 流式响应处理 - 直接返回，不要在这里设置响应头
        const aiMessageId = uuidv4();
        
        try {
          // 直接调用流式服务，由它来设置响应头和处理流
          await AIStreamService.sendStreamMessage(res, conversation.model_name, aiMessages, {
            temperature: conversation.getTemperature(),
            messageId: aiMessageId,
            conversationId: id,
            userId: userId,
            userMessage: userMessage.toJSON(),
            creditsInfo: {
              credits_consumed: creditsConsumed,
              credits_remaining: creditsResult.balanceAfter,
              model_credits_per_chat: requiredCredits
            },
            onComplete: async (fullContent, tokens) => {
              // 流式完成后保存AI消息
              try {
                const assistantMessage = await Message.create({
                  id: aiMessageId,
                  conversation_id: id,
                  role: 'assistant',
                  content: fullContent,
                  tokens: tokens || Message.estimateTokens(fullContent)
                });

                // 更新会话统计
                const totalTokens = userMessage.tokens + assistantMessage.tokens;
                await conversation.updateStats(2, totalTokens);
                await user.consumeTokens(totalTokens);

                // 清除消息缓存（有新消息）
                await CacheService.clearConversationCache(userId, id);

                // 更新统计数据
                await StatsService.updateUserDailyStats(userId, {
                  messages: 1,
                  tokens: totalTokens
                });
                
                // 记录模型使用
                await StatsService.recordModelUsage(conversation.model_name);

                // 如果是第一条消息且标题是默认的，自动生成标题
                if (conversation.title === 'New Chat' && conversationBackup.message_count === 0) {
                  const autoTitle = content.substring(0, 30) + (content.length > 30 ? '...' : '');
                  await conversation.update({ title: autoTitle });
                }

                logger.info('流式AI对话完成', { 
                  userId,
                  conversationId: id,
                  messageId: aiMessageId,
                  totalTokens,
                  creditsConsumed
                });
              } catch (error) {
                logger.error('保存流式消息失败:', error);
              }
            }
          });
          
          // 流式响应已经由 AIStreamService 处理，这里不需要返回任何内容
          return;
          
        } catch (aiError) {
          // AI调用失败，退还积分
          logger.error('流式AI调用失败，开始退还积分', {
            userId,
            conversationId: id,
            creditsToRefund: creditsConsumed,
            aiError: aiError.message
          });

          try {
            await user.addCredits(creditsConsumed, `流式AI调用失败退款 - ${aiError.message}`);
            logger.info('积分退还成功', { userId, creditsRefunded: creditsConsumed });
          } catch (refundError) {
            logger.error('积分退还失败', { refundError: refundError.message });
          }

          throw aiError;
        }
        
      } else {
        // 非流式响应处理（原有逻辑）
        try {
          const aiResponse = await AIService.sendMessage(
            conversation.model_name,
            aiMessages,
            { temperature: conversation.getTemperature() }
          );

          // 创建AI回复消息
          const assistantMessage = await Message.create({
            conversation_id: id,
            role: 'assistant',
            content: aiResponse.content,
            tokens: aiResponse.usage?.completion_tokens || Message.estimateTokens(aiResponse.content)
          });

          // 更新会话统计
          const totalTokens = userMessage.tokens + assistantMessage.tokens;
          await conversation.updateStats(2, totalTokens);
          await user.consumeTokens(totalTokens);

          // 清除消息缓存（有新消息）
          await CacheService.clearConversationCache(userId, id);

          // 更新统计数据
          await StatsService.updateUserDailyStats(userId, {
            messages: 1,
            tokens: totalTokens
          });
          
          // 记录模型使用
          await StatsService.recordModelUsage(conversation.model_name);

          // 如果是第一条消息且标题是默认的，自动生成标题
          if (conversation.title === 'New Chat' && conversationBackup.message_count === 0) {
            const autoTitle = content.substring(0, 30) + (content.length > 30 ? '...' : '');
            await conversation.update({ title: autoTitle });
          }

          logger.info('AI对话成功完成', { 
            userId,
            conversationId: id,
            totalTokens,
            creditsConsumed
          });

          // 处理响应中的文件信息
          const userMessageData = userMessage.toJSON();
          const assistantMessageData = assistantMessage.toJSON();
          
          if (userMessageData.file_id) {
            const file = await File.findById(userMessageData.file_id);
            if (file) {
              userMessageData.file = file.toJSON();
            }
          }

          return ResponseHelper.success(res, {
            user_message: userMessageData,
            assistant_message: assistantMessageData,
            conversation: conversation.toJSON(),
            usage: {
              total_tokens: totalTokens,
              user_tokens: userMessage.tokens,
              assistant_tokens: assistantMessage.tokens
            },
            credits_info: {
              credits_consumed: creditsConsumed,
              credits_remaining: creditsResult.balanceAfter,
              model_credits_per_chat: requiredCredits
            }
          }, 'AI对话完成');

        } catch (aiError) {
          // AI调用失败，退还积分
          logger.error('AI调用失败，开始退还积分', {
            userId,
            conversationId: id,
            creditsToRefund: creditsConsumed,
            aiError: aiError.message
          });

          try {
            await user.addCredits(creditsConsumed, `AI调用失败退款 - ${aiError.message}`);
            logger.info('积分退还成功', { userId, creditsRefunded: creditsConsumed });
          } catch (refundError) {
            logger.error('积分退还失败', { refundError: refundError.message });
          }

          throw aiError;
        }
      }

    } catch (error) {
      logger.error('发送消息失败', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        creditsConsumed,
        error: error.message,
        stack: error.stack
      });

      // 如果还没有发送SSE响应，返回普通错误
      if (!res.headersSent) {
        return ResponseHelper.error(res, error.message || '消息发送失败');
      }
    }
  }

  /**
   * 获取可用的AI模型列表 - 根据用户权限和限制过滤
   * GET /api/chat/models
   */
  static async getModels(req, res) {
    try {
      // 获取用户的ID和组ID
      const userId = req.user.id;
      const userGroupId = req.user.group_id;
      
      // 根据用户权限和限制获取可用的模型
      const models = await AIModel.getUserAvailableModels(userId, userGroupId);
      
      // 添加积分和图片支持信息到模型列表
      const modelsWithInfo = models.map(model => ({
        ...model,
        credits_per_chat: model.credits_per_chat || 10,
        credits_display: `${model.credits_per_chat || 10} 积分/次`,
        image_upload_enabled: model.image_upload_enabled || false
      }));
      
      logger.info('获取用户可用AI模型列表', {
        userId: req.user.id,
        groupId: userGroupId,
        modelCount: modelsWithInfo.length
      });
      
      return ResponseHelper.success(res, modelsWithInfo, '获取AI模型列表成功');
    } catch (error) {
      logger.error('获取AI模型列表失败', { 
        userId: req.user?.id, 
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, '获取AI模型列表失败');
    }
  }

  /**
   * 获取用户积分状态
   * GET /api/chat/credits
   */
  static async getUserCredits(req, res) {
    try {
      const userId = req.user.id;
      const user = await User.findById(userId);
      
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }
      
      const creditsStats = user.getCreditsStats();
      
      return ResponseHelper.success(res, {
        user_id: userId,
        credits_stats: creditsStats,
        can_chat: user.hasCredits(10)
      }, '获取用户积分状态成功');
      
    } catch (error) {
      logger.error('获取用户积分状态失败', {
        userId: req.user?.id,
        error: error.message
      });
      return ResponseHelper.error(res, '获取积分状态失败');
    }
  }

  /**
   * 保存对话草稿
   * POST /api/chat/conversations/:id/draft
   */
  static async saveDraft(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const { content } = req.body;

      // 检查会话所有权
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, '无权访问此会话');
      }

      // 保存草稿
      const saved = await CacheService.saveDraft(userId, id, content);
      
      if (saved) {
        return ResponseHelper.success(res, { saved: true }, '草稿保存成功');
      } else {
        return ResponseHelper.success(res, { saved: false }, '草稿保存失败（Redis未连接）');
      }
    } catch (error) {
      logger.error('保存草稿失败', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, '保存草稿失败');
    }
  }

  /**
   * 获取对话草稿
   * GET /api/chat/conversations/:id/draft
   */
  static async getDraft(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;

      // 检查会话所有权
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, '无权访问此会话');
      }

      // 获取草稿
      const draft = await CacheService.getDraft(userId, id);
      
      return ResponseHelper.success(res, { draft: draft || '' }, '获取草稿成功');
    } catch (error) {
      logger.error('获取草稿失败', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, '获取草稿失败');
    }
  }

  /**
   * 删除对话草稿
   * DELETE /api/chat/conversations/:id/draft
   */
  static async deleteDraft(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;

      // 检查会话所有权
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, '无权访问此会话');
      }

      // 删除草稿
      const deleted = await CacheService.deleteDraft(userId, id);
      
      return ResponseHelper.success(res, { deleted }, '草稿删除成功');
    } catch (error) {
      logger.error('删除草稿失败', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, '删除草稿失败');
    }
  }
}

module.exports = ChatController;

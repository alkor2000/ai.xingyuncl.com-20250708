/**
 * 管理员控制器 - 支持基于用户组的权限管理和用户备注
 */

const User = require('../models/User');
const AIModel = require('../models/AIModel');
const ResponseHelper = require('../utils/response');
const logger = require('../utils/logger');
const config = require('../config');
const dbConnection = require('../database/connection');

class AdminController {
  
  /**
   * 获取系统统计 - 基于用户组过滤
   */
  static async getSystemStats(req, res) {
    try {
      const currentUser = req.user;
      let groupFilter = '';
      let groupParams = [];

      // 如果是普通管理员，只能看到自己组的统计
      if (currentUser.role === 'admin' && currentUser.group_id) {
        groupFilter = 'WHERE u.group_id = ?';
        groupParams = [currentUser.group_id];
      }

      // 获取用户统计
      const userStatsQuery = `
        SELECT 
          COUNT(*) as total_users,
          SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active_users,
          SUM(CASE WHEN role = 'admin' OR role = 'super_admin' THEN 1 ELSE 0 END) as admin_users,
          SUM(used_tokens) as total_tokens_used,
          AVG(used_tokens) as avg_tokens_per_user,
          SUM(credits_quota) as total_credits_quota,
          SUM(used_credits) as total_credits_used,
          AVG(credits_quota - used_credits) as avg_credits_remaining
        FROM users u
        ${groupFilter}
      `;
      const { rows: userStats } = await dbConnection.query(userStatsQuery, groupParams);
      
      // 获取分组统计 - 管理员只能看到自己组的统计
      let groupStatsQuery;
      let groupStatsParams = [];
      
      if (currentUser.role === 'admin' && currentUser.group_id) {
        groupStatsQuery = `
          SELECT g.name, g.color, COUNT(u.id) as user_count, 
                 AVG(u.used_tokens) as avg_tokens,
                 AVG(u.used_credits) as avg_credits,
                 SUM(u.credits_quota - u.used_credits) as total_credits_remaining
          FROM user_groups g
          LEFT JOIN users u ON g.id = u.group_id AND u.status = 'active'
          WHERE g.id = ?
          GROUP BY g.id
        `;
        groupStatsParams = [currentUser.group_id];
      } else {
        groupStatsQuery = `
          SELECT g.name, g.color, COUNT(u.id) as user_count, 
                 AVG(u.used_tokens) as avg_tokens,
                 AVG(u.used_credits) as avg_credits,
                 SUM(u.credits_quota - u.used_credits) as total_credits_remaining
          FROM user_groups g
          LEFT JOIN users u ON g.id = u.group_id AND u.status = 'active'
          GROUP BY g.id
          ORDER BY g.sort_order ASC
        `;
      }
      
      const { rows: groupStats } = await dbConnection.query(groupStatsQuery, groupStatsParams);
      
      // 获取对话统计 - 基于用户组过滤
      let conversationStatsQuery;
      let conversationParams = [];
      
      if (currentUser.role === 'admin' && currentUser.group_id) {
        conversationStatsQuery = `
          SELECT 
            COUNT(DISTINCT c.id) as total_conversations,
            SUM(c.message_count) as total_messages,
            SUM(c.total_tokens) as conversation_tokens,
            AVG(c.message_count) as avg_messages_per_conversation
          FROM conversations c
          INNER JOIN users u ON c.user_id = u.id
          WHERE u.group_id = ?
        `;
        conversationParams = [currentUser.group_id];
      } else {
        conversationStatsQuery = `
          SELECT 
            COUNT(*) as total_conversations,
            SUM(message_count) as total_messages,
            SUM(total_tokens) as conversation_tokens,
            AVG(message_count) as avg_messages_per_conversation
          FROM conversations
        `;
      }
      
      const { rows: conversationStats } = await dbConnection.query(conversationStatsQuery, conversationParams);
      
      // AI模型统计 - 所有管理员都可以看到
      const modelStatsQuery = `
        SELECT 
          am.display_name as model_name,
          am.credits_per_chat,
          COUNT(c.id) as conversation_count,
          SUM(c.total_tokens) as total_tokens
        FROM ai_models am
        LEFT JOIN conversations c ON am.name = c.model_name 
        WHERE am.is_active = 1
        GROUP BY am.id
        ORDER BY conversation_count DESC
        LIMIT 10
      `;
      const { rows: modelStats } = await dbConnection.query(modelStatsQuery);

      const stats = {
        users: userStats[0] || {},
        groups: groupStats || [],
        conversations: conversationStats[0] || {},
        models: modelStats || []
      };

      logger.info('获取系统统计成功', { 
        adminId: req.user.id,
        adminRole: req.user.role,
        adminGroupId: req.user.group_id,
        stats: Object.keys(stats)
      });

      return ResponseHelper.success(res, stats, '获取系统统计成功');
    } catch (error) {
      logger.error('获取系统统计失败', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, '获取系统统计失败');
    }
  }

  /**
   * 获取用户列表 - 基于用户组权限过滤
   */
  static async getUsers(req, res) {
    try {
      const currentUser = req.user;
      const { 
        page = 1, 
        limit = 20, 
        role = null, 
        status = null, 
        group_id = null,
        search = null 
      } = req.query;

      // 传递当前用户信息用于权限过滤
      const result = await User.getList({
        page: parseInt(page),
        limit: parseInt(limit),
        role,
        status,
        group_id: group_id ? parseInt(group_id) : null,
        search
      }, currentUser);

      return ResponseHelper.paginated(res, result.users, result.pagination, '获取用户列表成功');
    } catch (error) {
      logger.error('获取用户列表失败', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, '获取用户列表失败');
    }
  }

  /**
   * 获取用户详情 - 检查用户组权限
   */
  static async getUserDetail(req, res) {
    try {
      const currentUser = req.user;
      const { id } = req.params;
      
      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      // 检查权限：管理员只能查看同组用户
      if (currentUser.role === 'admin' && currentUser.group_id !== user.group_id) {
        logger.warn('管理员尝试查看其他组用户详情', {
          adminId: currentUser.id,
          adminGroupId: currentUser.group_id,
          targetUserId: user.id,
          targetGroupId: user.group_id
        });
        return ResponseHelper.forbidden(res, '无权查看其他组用户');
      }

      const permissions = await user.getPermissions();

      logger.info('获取用户详情成功', { 
        adminId: req.user.id,
        targetUserId: id
      });

      return ResponseHelper.success(res, {
        user: user.toJSON(),
        permissions
      }, '获取用户详情成功');
    } catch (error) {
      logger.error('获取用户详情失败', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, '获取用户详情失败');
    }
  }

  /**
   * 创建用户 - 管理员只能创建同组用户
   */
  static async createUser(req, res) {
    try {
      const currentUser = req.user;
      const { 
        email, 
        username, 
        password, 
        role = 'user', 
        group_id = null,
        status = 'active', 
        token_quota = 10000,
        credits_quota = 1000,
        remark = null
      } = req.body;

      // 权限检查
      if (currentUser.role === 'admin') {
        // 管理员只能创建同组的普通用户
        if (role !== 'user') {
          return ResponseHelper.forbidden(res, '管理员只能创建普通用户');
        }
        
        // 强制设置为管理员所在组
        const finalGroupId = currentUser.group_id;
        
        const user = await User.create({
          email,
          username,
          password,
          role: 'user', // 管理员只能创建普通用户
          group_id: finalGroupId,
          status,
          token_quota,
          credits_quota,
          remark // 允许管理员设置备注
        });

        logger.info('管理员创建同组用户成功', { 
          adminId: currentUser.id,
          adminGroupId: currentUser.group_id,
          newUserId: user.id,
          email,
          role: 'user',
          group_id: finalGroupId
        });

        return ResponseHelper.success(res, user.toJSON(), '用户创建成功', 201);
      }

      // 超级管理员可以创建任何用户并设置备注
      const user = await User.create({
        email,
        username,
        password,
        role,
        group_id: group_id || null,
        status,
        token_quota,
        credits_quota,
        remark
      });

      logger.info('超级管理员创建用户成功', { 
        adminId: currentUser.id,
        newUserId: user.id,
        email,
        role,
        group_id
      });

      return ResponseHelper.success(res, user.toJSON(), '用户创建成功', 201);
    } catch (error) {
      logger.error('创建用户失败', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, '创建用户失败');
    }
  }

  /**
   * 更新用户 - 基于用户组权限
   */
  static async updateUser(req, res) {
    try {
      const currentUser = req.user;
      const { id } = req.params;
      const updateData = req.body;

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      // 权限检查
      if (currentUser.role === 'admin') {
        // 管理员只能更新同组用户
        if (currentUser.group_id !== user.group_id) {
          logger.warn('管理员尝试更新其他组用户', {
            adminId: currentUser.id,
            adminGroupId: currentUser.group_id,
            targetUserId: user.id,
            targetGroupId: user.group_id
          });
          return ResponseHelper.forbidden(res, '无权更新其他组用户');
        }

        // 管理员不能修改的字段（移除了remark，允许管理员修改备注）
        const restrictedFields = ['role', 'group_id', 'credits_quota', 'token_quota', 'credits_expire_at'];
        restrictedFields.forEach(field => {
          if (field in updateData) {
            delete updateData[field];
            logger.warn('管理员尝试修改受限字段', {
              adminId: currentUser.id,
              field,
              targetUserId: user.id
            });
          }
        });

        // 管理员不能将用户提升为管理员
        if (updateData.role && updateData.role !== 'user') {
          return ResponseHelper.forbidden(res, '管理员不能修改用户角色');
        }
      }

      const updatedUser = await user.update(updateData);

      logger.info('更新用户成功', { 
        adminId: currentUser.id,
        adminRole: currentUser.role,
        targetUserId: id,
        updateFields: Object.keys(updateData)
      });

      return ResponseHelper.success(res, updatedUser.toJSON(), '用户更新成功');
    } catch (error) {
      logger.error('更新用户失败', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, '更新用户失败');
    }
  }

  /**
   * 删除用户 - 基于用户组权限
   */
  static async deleteUser(req, res) {
    try {
      const currentUser = req.user;
      const { id } = req.params;

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      // 权限检查
      if (currentUser.role === 'admin') {
        // 管理员只能删除同组的普通用户
        if (currentUser.group_id !== user.group_id) {
          return ResponseHelper.forbidden(res, '无权删除其他组用户');
        }
        
        if (user.role !== 'user') {
          return ResponseHelper.forbidden(res, '管理员只能删除普通用户');
        }
      }

      // 防止删除自己
      if (user.id === currentUser.id) {
        return ResponseHelper.forbidden(res, '不能删除自己的账户');
      }

      await user.delete();

      logger.info('删除用户成功', { 
        adminId: currentUser.id,
        adminRole: currentUser.role,
        deletedUserId: id,
        deletedEmail: user.email
      });

      return ResponseHelper.success(res, null, '用户删除成功');
    } catch (error) {
      logger.error('删除用户失败', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, '删除用户失败');
    }
  }

  /**
   * 重置用户密码 - 基于用户组权限
   */
  static async resetUserPassword(req, res) {
    try {
      const currentUser = req.user;
      const { id } = req.params;
      const { newPassword } = req.body;

      if (!newPassword || newPassword.length < 6) {
        return ResponseHelper.validation(res, ['密码长度至少6位']);
      }

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      // 权限检查
      const hasPermission = await currentUser.hasPermission('user.password.group', user.id);
      if (!hasPermission) {
        logger.warn('无权重置用户密码', {
          adminId: currentUser.id,
          adminRole: currentUser.role,
          adminGroupId: currentUser.group_id,
          targetUserId: user.id,
          targetGroupId: user.group_id
        });
        return ResponseHelper.forbidden(res, '无权重置该用户密码');
      }

      // 使用 password 字段而不是 password_hash，让 User 模型自动处理加密
      await user.update({ password: newPassword });

      logger.info('管理员重置用户密码成功', { 
        adminId: currentUser.id,
        adminRole: currentUser.role,
        targetUserId: id,
        targetEmail: user.email
      });

      return ResponseHelper.success(res, null, '密码重置成功');
    } catch (error) {
      logger.error('重置用户密码失败', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, '密码重置失败');
    }
  }

  // ===== 积分管理接口 - 管理员只能查看 =====

  /**
   * 获取用户积分信息 - 管理员只能查看同组用户
   */
  static async getUserCredits(req, res) {
    try {
      const currentUser = req.user;
      const { id } = req.params;
      
      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      // 权限检查：管理员只能查看同组用户的积分
      if (currentUser.role === 'admin') {
        if (currentUser.group_id !== user.group_id) {
          return ResponseHelper.forbidden(res, '无权查看其他组用户的积分信息');
        }
      }

      const creditsInfo = {
        user_id: user.id,
        user_email: user.email,
        credits_quota: user.credits_quota,
        used_credits: user.used_credits,
        credits_expire_at: user.credits_expire_at,
        credits_stats: user.getCreditsStats()
      };

      logger.info('获取用户积分信息成功', { 
        adminId: currentUser.id,
        adminRole: currentUser.role,
        targetUserId: id,
        creditsInfo
      });

      return ResponseHelper.success(res, creditsInfo, '获取用户积分信息成功');
    } catch (error) {
      logger.error('获取用户积分信息失败', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, '获取用户积分信息失败');
    }
  }

  /**
   * 设置用户积分配额 - 仅超级管理员
   */
  static async setUserCredits(req, res) {
    try {
      const currentUser = req.user;
      
      // 只有超级管理员可以设置积分
      if (currentUser.role !== 'super_admin') {
        return ResponseHelper.forbidden(res, '只有超级管理员可以设置积分配额');
      }

      const { id } = req.params;
      const { credits_quota, reason = '管理员调整积分配额', expire_date } = req.body;
      
      if (typeof credits_quota !== 'number' || credits_quota < 0) {
        return ResponseHelper.validation(res, ['积分配额必须是非负数字']);
      }

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      // 设置积分配额
      const result = await user.setCreditsQuota(credits_quota, reason, req.user.id);
      
      // 如果提供了过期日期，同时设置过期时间
      if (expire_date) {
        await user.setCreditsExpireDate(new Date(expire_date), reason, req.user.id);
      }

      logger.info('超级管理员设置用户积分配额成功', { 
        adminId: req.user.id,
        targetUserId: id,
        newQuota: credits_quota,
        expireDate: expire_date,
        reason
      });

      return ResponseHelper.success(res, result, '积分配额设置成功');
    } catch (error) {
      logger.error('设置用户积分配额失败', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, error.message || '设置积分配额失败');
    }
  }

  /**
   * 充值用户积分 - 仅超级管理员
   */
  static async addUserCredits(req, res) {
    try {
      const currentUser = req.user;
      
      // 只有超级管理员可以充值积分
      if (currentUser.role !== 'super_admin') {
        return ResponseHelper.forbidden(res, '只有超级管理员可以充值积分');
      }

      const { id } = req.params;
      const { amount, reason = '管理员充值积分', extend_days } = req.body;
      
      if (typeof amount !== 'number' || amount <= 0) {
        return ResponseHelper.validation(res, ['充值金额必须是正数']);
      }

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      const result = await user.addCredits(amount, reason, req.user.id, extend_days);

      logger.info('超级管理员充值用户积分成功', { 
        adminId: req.user.id,
        targetUserId: id,
        amount,
        extendDays: extend_days,
        reason
      });

      return ResponseHelper.success(res, result, '积分充值成功');
    } catch (error) {
      logger.error('充值用户积分失败', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, error.message || '充值积分失败');
    }
  }

  /**
   * 扣减用户积分 - 仅超级管理员
   */
  static async deductUserCredits(req, res) {
    try {
      const currentUser = req.user;
      
      // 只有超级管理员可以扣减积分
      if (currentUser.role !== 'super_admin') {
        return ResponseHelper.forbidden(res, '只有超级管理员可以扣减积分');
      }

      const { id } = req.params;
      const { amount, reason = '管理员扣减积分' } = req.body;
      
      if (typeof amount !== 'number' || amount <= 0) {
        return ResponseHelper.validation(res, ['扣减金额必须是正数']);
      }

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      const result = await user.deductCredits(amount, reason, req.user.id);

      logger.info('超级管理员扣减用户积分成功', { 
        adminId: req.user.id,
        targetUserId: id,
        amount,
        reason
      });

      return ResponseHelper.success(res, result, '积分扣减成功');
    } catch (error) {
      logger.error('扣减用户积分失败', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, error.message || '积分扣减失败');
    }
  }

  /**
   * 设置用户积分有效期 - 仅超级管理员
   */
  static async setUserCreditsExpire(req, res) {
    try {
      const currentUser = req.user;
      
      // 只有超级管理员可以设置积分有效期
      if (currentUser.role !== 'super_admin') {
        return ResponseHelper.forbidden(res, '只有超级管理员可以设置积分有效期');
      }

      const { id } = req.params;
      const { expire_date, extend_days, reason = '管理员设置积分有效期' } = req.body;
      
      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      let result;
      if (expire_date) {
        // 设置具体日期
        result = await user.setCreditsExpireDate(new Date(expire_date), reason, req.user.id);
      } else if (extend_days) {
        // 延长天数
        result = await user.extendCreditsExpireDate(extend_days, reason, req.user.id);
      } else {
        return ResponseHelper.validation(res, ['必须提供过期日期或延长天数']);
      }

      logger.info('超级管理员设置用户积分有效期成功', { 
        adminId: req.user.id,
        targetUserId: id,
        expireDate: expire_date,
        extendDays: extend_days,
        reason
      });

      return ResponseHelper.success(res, result, '积分有效期设置成功');
    } catch (error) {
      logger.error('设置用户积分有效期失败', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, error.message || '设置积分有效期失败');
    }
  }

  /**
   * 获取用户积分使用历史 - 管理员只能查看同组用户
   */
  static async getUserCreditsHistory(req, res) {
    try {
      const currentUser = req.user;
      const { id } = req.params;
      const { 
        page = 1, 
        limit = 20, 
        transaction_type = null 
      } = req.query;

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      // 权限检查：管理员只能查看同组用户的积分历史
      if (currentUser.role === 'admin') {
        if (currentUser.group_id !== user.group_id) {
          return ResponseHelper.forbidden(res, '无权查看其他组用户的积分历史');
        }
      }

      const result = await User.getCreditHistory(id, {
        page: parseInt(page),
        limit: parseInt(limit),
        transaction_type
      });

      logger.info('获取用户积分历史成功', { 
        adminId: currentUser.id,
        adminRole: currentUser.role,
        targetUserId: id,
        historyCount: result.history.length
      });

      return ResponseHelper.paginated(res, result.history, result.pagination, '获取积分历史成功');
    } catch (error) {
      logger.error('获取用户积分历史失败', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, '获取积分历史失败');
    }
  }

  // ===== 用户分组管理 =====

  /**
   * 获取用户分组列表 - 管理员只能看到自己的组
   */
  static async getUserGroups(req, res) {
    try {
      const currentUser = req.user;
      let groups;

      if (currentUser.role === 'admin' && currentUser.group_id) {
        // 管理员只能看到自己所在的组
        const sql = `
          SELECT g.*, 
                 COUNT(u.id) as user_count,
                 AVG(u.used_tokens) as avg_tokens_used,
                 AVG(u.used_credits) as avg_credits_used
          FROM user_groups g
          LEFT JOIN users u ON g.id = u.group_id AND u.status = 'active'
          WHERE g.id = ?
          GROUP BY g.id
        `;
        const { rows } = await dbConnection.query(sql, [currentUser.group_id]);
        groups = rows;
      } else {
        // 超级管理员可以看到所有组
        groups = await User.getGroups();
      }

      logger.info('获取用户分组列表成功', { 
        adminId: req.user.id,
        adminRole: req.user.role,
        groupCount: groups.length
      });

      return ResponseHelper.success(res, groups, '获取用户分组列表成功');
    } catch (error) {
      logger.error('获取用户分组列表失败', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, '获取用户分组列表失败');
    }
  }

  /**
   * 创建用户分组 - 仅超级管理员
   */
  static async createUserGroup(req, res) {
    try {
      if (req.user.role !== 'super_admin') {
        return ResponseHelper.forbidden(res, '只有超级管理员可以创建用户分组');
      }

      const groupData = req.body;
      const createdBy = req.user.id;

      const group = await User.createGroup(groupData, createdBy);

      logger.info('创建用户分组成功', { 
        adminId: req.user.id,
        groupId: group.id,
        groupName: group.name
      });

      return ResponseHelper.success(res, group, '用户分组创建成功', 201);
    } catch (error) {
      logger.error('创建用户分组失败', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, '创建用户分组失败');
    }
  }

  /**
   * 更新用户分组 - 仅超级管理员
   */
  static async updateUserGroup(req, res) {
    try {
      if (req.user.role !== 'super_admin') {
        return ResponseHelper.forbidden(res, '只有超级管理员可以更新用户分组');
      }

      const { id } = req.params;
      const updateData = req.body;

      const group = await User.updateGroup(id, updateData);
      if (!group) {
        return ResponseHelper.notFound(res, '用户分组不存在');
      }

      logger.info('更新用户分组成功', { 
        adminId: req.user.id,
        groupId: id,
        updateFields: Object.keys(updateData)
      });

      return ResponseHelper.success(res, group, '用户分组更新成功');
    } catch (error) {
      logger.error('更新用户分组失败', { 
        adminId: req.user?.id, 
        groupId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, '更新用户分组失败');
    }
  }

  /**
   * 删除用户分组 - 仅超级管理员
   */
  static async deleteUserGroup(req, res) {
    try {
      if (req.user.role !== 'super_admin') {
        return ResponseHelper.forbidden(res, '只有超级管理员可以删除用户分组');
      }

      const { id } = req.params;

      await User.deleteGroup(id);

      logger.info('删除用户分组成功', { 
        adminId: req.user.id,
        deletedGroupId: id
      });

      return ResponseHelper.success(res, null, '用户分组删除成功');
    } catch (error) {
      logger.error('删除用户分组失败', { 
        adminId: req.user?.id, 
        groupId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, error.message.includes('该分组下还有') ? error.message : '删除用户分组失败');
    }
  }

  // ===== AI模型管理 - 仅超级管理员 =====

  /**
   * 获取AI模型列表
   */
  static async getAIModels(req, res) {
    try {
      const sql = `
        SELECT *, 
        (SELECT COUNT(*) FROM conversations WHERE model_name = ai_models.name) as usage_count
        FROM ai_models 
        ORDER BY sort_order ASC, created_at ASC
      `;
      
      const { rows } = await dbConnection.query(sql);
      
      const models = rows.map(row => {
        const model = new AIModel(row);
        if (typeof model.model_config === 'string') {
          try {
            model.model_config = JSON.parse(model.model_config);
          } catch (e) {
            model.model_config = {};
          }
        }
        return model;
      });

      logger.info('获取AI模型列表成功', { 
        adminId: req.user.id,
        modelCount: models.length
      });

      return ResponseHelper.success(res, models, '获取AI模型列表成功');
    } catch (error) {
      logger.error('获取AI模型列表失败', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, '获取AI模型列表失败');
    }
  }

  /**
   * 创建AI模型
   */
  static async createAIModel(req, res) {
    try {
      const modelData = req.body;
      const model = await AIModel.create(modelData);

      logger.info('创建AI模型成功', { 
        adminId: req.user.id,
        modelId: model.id,
        modelName: model.name
      });

      return ResponseHelper.success(res, model.toJSON(), 'AI模型创建成功', 201);
    } catch (error) {
      logger.error('创建AI模型失败', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, '创建AI模型失败');
    }
  }

  /**
   * 更新AI模型
   */
  static async updateAIModel(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const model = await AIModel.findById(id);
      if (!model) {
        return ResponseHelper.notFound(res, 'AI模型不存在');
      }

      await model.update(updateData);
      
      const updatedModel = await AIModel.findById(id);
      if (!updatedModel) {
        logger.error('更新后重新获取模型失败', { modelId: id });
        return ResponseHelper.error(res, '更新后获取模型数据失败');
      }

      logger.info('更新AI模型成功', { 
        adminId: req.user.id,
        modelId: id,
        updateFields: Object.keys(updateData),
        streamEnabled: updatedModel.stream_enabled
      });

      return ResponseHelper.success(res, updatedModel.toJSON(), 'AI模型更新成功');
    } catch (error) {
      logger.error('更新AI模型失败', { 
        adminId: req.user?.id, 
        modelId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, '更新AI模型失败');
    }
  }

  /**
   * 删除AI模型
   */
  static async deleteAIModel(req, res) {
    try {
      const { id } = req.params;

      const model = await AIModel.findById(id);
      if (!model) {
        return ResponseHelper.notFound(res, 'AI模型不存在');
      }

      await model.delete();

      logger.info('删除AI模型成功', { 
        adminId: req.user.id,
        deletedModelId: id,
        deletedModelName: model.name
      });

      return ResponseHelper.success(res, null, 'AI模型删除成功');
    } catch (error) {
      logger.error('删除AI模型失败', { 
        adminId: req.user?.id, 
        modelId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, '删除AI模型失败');
    }
  }

  /**
   * 测试AI模型连通性
   */
  static async testAIModel(req, res) {
    try {
      const { id } = req.params;

      const model = await AIModel.findById(id);
      if (!model) {
        return ResponseHelper.notFound(res, 'AI模型不存在');
      }

      const testResult = await model.testConnection();

      logger.info('AI模型连通性测试完成', { 
        adminId: req.user.id,
        modelId: id,
        testSuccess: testResult.success
      });

      return ResponseHelper.success(res, testResult, '连通性测试完成');
    } catch (error) {
      logger.error('AI模型连通性测试失败', { 
        adminId: req.user?.id, 
        modelId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, '连通性测试失败');
    }
  }

  /**
   * 获取系统设置
   */
  static async getSystemSettings(req, res) {
    try {
      const settings = {
        site: {
          name: 'AI Platform',
          description: '企业级AI应用聚合平台',
          logo: '',
          favicon: ''
        },
        user: {
          allow_register: true,
          default_token_quota: 10000,
          default_group_id: 1,
          default_credits_quota: 1000
        },
        ai: {
          default_model: 'openai/gpt-4.1-mini',
          temperature: 0.0
        },
        credits: {
          default_credits: 1000,
          max_credits: 100000,
          min_credits_for_chat: 1
        }
      };

      return ResponseHelper.success(res, settings, '获取系统设置成功');
    } catch (error) {
      logger.error('获取系统设置失败', { 
        userId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, '获取系统设置失败');
    }
  }

  /**
   * 更新系统设置
   */
  static async updateSystemSettings(req, res) {
    try {
      const settings = req.body;

      logger.info('管理员更新系统设置', { 
        adminId: req.user.id,
        settings
      });

      return ResponseHelper.success(res, settings, '系统设置更新成功');
    } catch (error) {
      logger.error('更新系统设置失败', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, '更新系统设置失败');
    }
  }
}

module.exports = AdminController;

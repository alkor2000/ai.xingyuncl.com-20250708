/**
 * ç®¡ç†å‘˜æ§åˆ¶å™¨ - æ”¯æŒç”¨æˆ·åˆ†ç»„ç®¡ç†å’Œç§¯åˆ†ç®¡ç†ï¼ˆä¿®å¤æµå¼å¼€å…³Bugç‰ˆæœ¬ï¼‰
 */

const User = require('../models/User');
const AIModel = require('../models/AIModel');
const ResponseHelper = require('../utils/response');
const logger = require('../utils/logger');
const config = require('../config');
const dbConnection = require('../database/connection');

class AdminController {
  
  /**
   * è·å–ç³»ç»Ÿç»Ÿè®¡ - åŒ…å«åˆ†ç»„ç»Ÿè®¡å’Œç§¯åˆ†ç»Ÿè®¡
   */
  static async getSystemStats(req, res) {
    try {
      // è·å–ç”¨æˆ·ç»Ÿè®¡
      const userStatsQuery = `
        SELECT 
          COUNT(*) as total_users,
          SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active_users,
          SUM(CASE WHEN role = 'admin' OR role = 'super_admin' THEN 1 ELSE 0 END) as admin_users,
          SUM(used_tokens) as total_tokens_used,
          AVG(used_tokens) as avg_tokens_per_user,
          SUM(credits_quota) as total_credits_quota,
          SUM(used_credits) as total_credits_used,
          AVG(credits_quota - used_credits) as avg_credits_remaining
        FROM users
      `;
      const { rows: userStats } = await dbConnection.query(userStatsQuery);
      
      // è·å–åˆ†ç»„ç»Ÿè®¡
      const groupStatsQuery = `
        SELECT g.name, g.color, COUNT(u.id) as user_count, 
               AVG(u.used_tokens) as avg_tokens,
               AVG(u.used_credits) as avg_credits,
               SUM(u.credits_quota - u.used_credits) as total_credits_remaining
        FROM user_groups g
        LEFT JOIN users u ON g.id = u.group_id AND u.status = 'active'
        GROUP BY g.id
        ORDER BY g.sort_order ASC
      `;
      const { rows: groupStats } = await dbConnection.query(groupStatsQuery);
      
      // è·å–å¯¹è¯ç»Ÿè®¡
      const conversationStatsQuery = `
        SELECT 
          COUNT(*) as total_conversations,
          SUM(message_count) as total_messages,
          SUM(total_tokens) as conversation_tokens,
          AVG(message_count) as avg_messages_per_conversation
        FROM conversations
      `;
      const { rows: conversationStats } = await dbConnection.query(conversationStatsQuery);
      
      // è·å–AIæ¨¡å‹ä½¿ç”¨ç»Ÿè®¡ (åŒ…å«ç§¯åˆ†æ¶ˆè´¹)
      const modelStatsQuery = `
        SELECT 
          am.display_name as model_name,
          am.credits_per_chat,
          COUNT(c.id) as conversation_count,
          SUM(c.total_tokens) as total_tokens,
          COUNT(ct.id) as credit_transactions,
          SUM(ABS(ct.amount)) as total_credits_consumed
        FROM ai_models am
        LEFT JOIN conversations c ON am.name = c.model_name 
        LEFT JOIN credit_transactions ct ON am.id = ct.related_model_id
        WHERE am.is_active = 1
        GROUP BY am.id
        ORDER BY conversation_count DESC
        LIMIT 10
      `;
      const { rows: modelStats } = await dbConnection.query(modelStatsQuery);

      const stats = {
        users: userStats[0] || {},
        groups: groupStats || [],
        conversations: conversationStats[0] || {},
        models: modelStats || []
      };

      logger.info('è·å–ç³»ç»Ÿç»Ÿè®¡æˆåŠŸ', { 
        adminId: req.user.id,
        stats: Object.keys(stats)
      });

      return ResponseHelper.success(res, stats, 'è·å–ç³»ç»Ÿç»Ÿè®¡æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–ç³»ç»Ÿç»Ÿè®¡å¤±è´¥', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, 'è·å–ç³»ç»Ÿç»Ÿè®¡å¤±è´¥');
    }
  }

  /**
   * è·å–ç”¨æˆ·åˆ—è¡¨ - æ”¯æŒåˆ†ç»„è¿‡æ»¤
   */
  static async getUsers(req, res) {
    try {
      const { 
        page = 1, 
        limit = 20, 
        role = null, 
        status = null, 
        group_id = null,
        search = null 
      } = req.query;

      const result = await User.getList({
        page: parseInt(page),
        limit: parseInt(limit),
        role,
        status,
        group_id: group_id ? parseInt(group_id) : null,
        search
      });

      return ResponseHelper.paginated(res, result.users, result.pagination, 'è·å–ç”¨æˆ·åˆ—è¡¨æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, 'è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * è·å–ç”¨æˆ·è¯¦æƒ… (åŒ…å«ç§¯åˆ†ä¿¡æ¯)
   */
  static async getUserDetail(req, res) {
    try {
      const { id } = req.params;
      
      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, 'ç”¨æˆ·ä¸å­˜åœ¨');
      }

      const permissions = await user.getPermissions();

      logger.info('è·å–ç”¨æˆ·è¯¦æƒ…æˆåŠŸ', { 
        adminId: req.user.id,
        targetUserId: id
      });

      return ResponseHelper.success(res, {
        user: user.toJSON(),
        permissions
      }, 'è·å–ç”¨æˆ·è¯¦æƒ…æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–ç”¨æˆ·è¯¦æƒ…å¤±è´¥', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'è·å–ç”¨æˆ·è¯¦æƒ…å¤±è´¥');
    }
  }

  /**
   * åˆ›å»ºç”¨æˆ· - æ”¯æŒåˆ†ç»„è®¾ç½®å’Œç§¯åˆ†é…é¢
   */
  static async createUser(req, res) {
    try {
      const { 
        email, 
        username, 
        password, 
        role = 'user', 
        group_id = null,
        status = 'active', 
        token_quota = 10000,
        credits_quota = 1000
      } = req.body;

      // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
      const existingEmail = await User.findByEmail(email);
      if (existingEmail) {
        return ResponseHelper.validation(res, ['é‚®ç®±å·²è¢«ä½¿ç”¨']);
      }

      // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
      const existingUsername = await User.findByUsername(username);
      if (existingUsername) {
        return ResponseHelper.validation(res, ['ç”¨æˆ·åå·²è¢«ä½¿ç”¨']);
      }

      const user = await User.create({
        email,
        username,
        password,
        role,
        group_id: group_id || null,
        status,
        token_quota,
        credits_quota
      });

      logger.info('ç®¡ç†å‘˜åˆ›å»ºç”¨æˆ·æˆåŠŸ', { 
        adminId: req.user.id,
        newUserId: user.id,
        email,
        role,
        group_id,
        credits_quota
      });

      return ResponseHelper.success(res, user.toJSON(), 'ç”¨æˆ·åˆ›å»ºæˆåŠŸ', 201);
    } catch (error) {
      logger.error('åˆ›å»ºç”¨æˆ·å¤±è´¥', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, 'åˆ›å»ºç”¨æˆ·å¤±è´¥');
    }
  }

  /**
   * æ›´æ–°ç”¨æˆ· - æ”¯æŒåˆ†ç»„æ›´æ–°å’Œç§¯åˆ†é…é¢
   */
  static async updateUser(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, 'ç”¨æˆ·ä¸å­˜åœ¨');
      }

      const updatedUser = await user.update(updateData);

      logger.info('ç®¡ç†å‘˜æ›´æ–°ç”¨æˆ·æˆåŠŸ', { 
        adminId: req.user.id,
        targetUserId: id,
        updateFields: Object.keys(updateData)
      });

      return ResponseHelper.success(res, updatedUser.toJSON(), 'ç”¨æˆ·æ›´æ–°æˆåŠŸ');
    } catch (error) {
      logger.error('æ›´æ–°ç”¨æˆ·å¤±è´¥', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'æ›´æ–°ç”¨æˆ·å¤±è´¥');
    }
  }

  /**
   * åˆ é™¤ç”¨æˆ·
   */
  static async deleteUser(req, res) {
    try {
      const { id } = req.params;

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, 'ç”¨æˆ·ä¸å­˜åœ¨');
      }

      await user.delete();

      logger.info('ç®¡ç†å‘˜åˆ é™¤ç”¨æˆ·æˆåŠŸ', { 
        adminId: req.user.id,
        deletedUserId: id,
        deletedEmail: user.email
      });

      return ResponseHelper.success(res, null, 'ç”¨æˆ·åˆ é™¤æˆåŠŸ');
    } catch (error) {
      logger.error('åˆ é™¤ç”¨æˆ·å¤±è´¥', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'åˆ é™¤ç”¨æˆ·å¤±è´¥');
    }
  }

  // ===== ç§¯åˆ†ç®¡ç†æ¥å£ (æ ¸å¿ƒåŠŸèƒ½) =====

  /**
   * è·å–ç”¨æˆ·ç§¯åˆ†ä¿¡æ¯
   * GET /api/admin/users/:id/credits
   */
  static async getUserCredits(req, res) {
    try {
      const { id } = req.params;
      
      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, 'ç”¨æˆ·ä¸å­˜åœ¨');
      }

      const creditsInfo = {
        user_id: user.id,
        user_email: user.email,
        credits_quota: user.credits_quota,
        used_credits: user.used_credits,
        credits_stats: user.getCreditsStats()
      };

      logger.info('è·å–ç”¨æˆ·ç§¯åˆ†ä¿¡æ¯æˆåŠŸ', { 
        adminId: req.user.id,
        targetUserId: id,
        creditsInfo
      });

      return ResponseHelper.success(res, creditsInfo, 'è·å–ç”¨æˆ·ç§¯åˆ†ä¿¡æ¯æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–ç”¨æˆ·ç§¯åˆ†ä¿¡æ¯å¤±è´¥', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'è·å–ç”¨æˆ·ç§¯åˆ†ä¿¡æ¯å¤±è´¥');
    }
  }

  /**
   * è®¾ç½®ç”¨æˆ·ç§¯åˆ†é…é¢
   * PUT /api/admin/users/:id/credits
   */
  static async setUserCredits(req, res) {
    try {
      const { id } = req.params;
      const { credits_quota, reason = 'ç®¡ç†å‘˜è°ƒæ•´ç§¯åˆ†é…é¢' } = req.body;
      
      if (typeof credits_quota !== 'number' || credits_quota < 0) {
        return ResponseHelper.validation(res, ['ç§¯åˆ†é…é¢å¿…é¡»æ˜¯éè´Ÿæ•°å­—']);
      }

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, 'ç”¨æˆ·ä¸å­˜åœ¨');
      }

      const result = await user.setCreditsQuota(credits_quota, reason, req.user.id);

      logger.info('ç®¡ç†å‘˜è®¾ç½®ç”¨æˆ·ç§¯åˆ†é…é¢æˆåŠŸ', { 
        adminId: req.user.id,
        targetUserId: id,
        newQuota: credits_quota,
        reason
      });

      return ResponseHelper.success(res, result, 'ç§¯åˆ†é…é¢è®¾ç½®æˆåŠŸ');
    } catch (error) {
      logger.error('è®¾ç½®ç”¨æˆ·ç§¯åˆ†é…é¢å¤±è´¥', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, error.message || 'è®¾ç½®ç§¯åˆ†é…é¢å¤±è´¥');
    }
  }

  /**
   * å……å€¼ç”¨æˆ·ç§¯åˆ†
   * POST /api/admin/users/:id/credits/add
   */
  static async addUserCredits(req, res) {
    try {
      const { id } = req.params;
      const { amount, reason = 'ç®¡ç†å‘˜å……å€¼ç§¯åˆ†' } = req.body;
      
      if (typeof amount !== 'number' || amount <= 0) {
        return ResponseHelper.validation(res, ['å……å€¼é‡‘é¢å¿…é¡»æ˜¯æ­£æ•°']);
      }

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, 'ç”¨æˆ·ä¸å­˜åœ¨');
      }

      const result = await user.addCredits(amount, reason, req.user.id);

      logger.info('ç®¡ç†å‘˜å……å€¼ç”¨æˆ·ç§¯åˆ†æˆåŠŸ', { 
        adminId: req.user.id,
        targetUserId: id,
        amount,
        reason
      });

      return ResponseHelper.success(res, result, 'ç§¯åˆ†å……å€¼æˆåŠŸ');
    } catch (error) {
      logger.error('å……å€¼ç”¨æˆ·ç§¯åˆ†å¤±è´¥', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, error.message || 'ç§¯åˆ†å……å€¼å¤±è´¥');
    }
  }

  /**
   * æ‰£å‡ç”¨æˆ·ç§¯åˆ†
   * POST /api/admin/users/:id/credits/deduct
   */
  static async deductUserCredits(req, res) {
    try {
      const { id } = req.params;
      const { amount, reason = 'ç®¡ç†å‘˜æ‰£å‡ç§¯åˆ†' } = req.body;
      
      if (typeof amount !== 'number' || amount <= 0) {
        return ResponseHelper.validation(res, ['æ‰£å‡é‡‘é¢å¿…é¡»æ˜¯æ­£æ•°']);
      }

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, 'ç”¨æˆ·ä¸å­˜åœ¨');
      }

      const result = await user.deductCredits(amount, reason, req.user.id);

      logger.info('ç®¡ç†å‘˜æ‰£å‡ç”¨æˆ·ç§¯åˆ†æˆåŠŸ', { 
        adminId: req.user.id,
        targetUserId: id,
        amount,
        reason
      });

      return ResponseHelper.success(res, result, 'ç§¯åˆ†æ‰£å‡æˆåŠŸ');
    } catch (error) {
      logger.error('æ‰£å‡ç”¨æˆ·ç§¯åˆ†å¤±è´¥', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, error.message || 'ç§¯åˆ†æ‰£å‡å¤±è´¥');
    }
  }

  /**
   * è·å–ç”¨æˆ·ç§¯åˆ†ä½¿ç”¨å†å²
   * GET /api/admin/users/:id/credits/history
   */
  static async getUserCreditsHistory(req, res) {
    try {
      const { id } = req.params;
      const { 
        page = 1, 
        limit = 20, 
        transaction_type = null 
      } = req.query;

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, 'ç”¨æˆ·ä¸å­˜åœ¨');
      }

      const result = await User.getCreditHistory(id, {
        page: parseInt(page),
        limit: parseInt(limit),
        transaction_type
      });

      logger.info('è·å–ç”¨æˆ·ç§¯åˆ†å†å²æˆåŠŸ', { 
        adminId: req.user.id,
        targetUserId: id,
        historyCount: result.history.length
      });

      return ResponseHelper.paginated(res, result.history, result.pagination, 'è·å–ç§¯åˆ†å†å²æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–ç”¨æˆ·ç§¯åˆ†å†å²å¤±è´¥', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'è·å–ç§¯åˆ†å†å²å¤±è´¥');
    }
  }

  // ===== ç”¨æˆ·åˆ†ç»„ç®¡ç† =====

  /**
   * è·å–ç”¨æˆ·åˆ†ç»„åˆ—è¡¨
   */
  static async getUserGroups(req, res) {
    try {
      const groups = await User.getGroups();

      logger.info('è·å–ç”¨æˆ·åˆ†ç»„åˆ—è¡¨æˆåŠŸ', { 
        adminId: req.user.id,
        groupCount: groups.length
      });

      return ResponseHelper.success(res, groups, 'è·å–ç”¨æˆ·åˆ†ç»„åˆ—è¡¨æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–ç”¨æˆ·åˆ†ç»„åˆ—è¡¨å¤±è´¥', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, 'è·å–ç”¨æˆ·åˆ†ç»„åˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * åˆ›å»ºç”¨æˆ·åˆ†ç»„
   */
  static async createUserGroup(req, res) {
    try {
      const groupData = req.body;
      const createdBy = req.user.id;

      const group = await User.createGroup(groupData, createdBy);

      logger.info('åˆ›å»ºç”¨æˆ·åˆ†ç»„æˆåŠŸ', { 
        adminId: req.user.id,
        groupId: group.id,
        groupName: group.name
      });

      return ResponseHelper.success(res, group, 'ç”¨æˆ·åˆ†ç»„åˆ›å»ºæˆåŠŸ', 201);
    } catch (error) {
      logger.error('åˆ›å»ºç”¨æˆ·åˆ†ç»„å¤±è´¥', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, 'åˆ›å»ºç”¨æˆ·åˆ†ç»„å¤±è´¥');
    }
  }

  /**
   * æ›´æ–°ç”¨æˆ·åˆ†ç»„
   */
  static async updateUserGroup(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const group = await User.updateGroup(id, updateData);
      if (!group) {
        return ResponseHelper.notFound(res, 'ç”¨æˆ·åˆ†ç»„ä¸å­˜åœ¨');
      }

      logger.info('æ›´æ–°ç”¨æˆ·åˆ†ç»„æˆåŠŸ', { 
        adminId: req.user.id,
        groupId: id,
        updateFields: Object.keys(updateData)
      });

      return ResponseHelper.success(res, group, 'ç”¨æˆ·åˆ†ç»„æ›´æ–°æˆåŠŸ');
    } catch (error) {
      logger.error('æ›´æ–°ç”¨æˆ·åˆ†ç»„å¤±è´¥', { 
        adminId: req.user?.id, 
        groupId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'æ›´æ–°ç”¨æˆ·åˆ†ç»„å¤±è´¥');
    }
  }

  /**
   * åˆ é™¤ç”¨æˆ·åˆ†ç»„
   */
  /**
   * é‡ç½®ç”¨æˆ·å¯†ç 
   * PUT /api/admin/users/:id/password
   */
  static async resetUserPassword(req, res) {
    try {
      const { id } = req.params;
      const { newPassword } = req.body;

      if (!newPassword || newPassword.length < 6) {
        return ResponseHelper.validation(res, ['å¯†ç é•¿åº¦è‡³å°‘6ä½']);
      }

      const user = await User.findById(id);
      if (!user) {
        return ResponseHelper.notFound(res, 'ç”¨æˆ·ä¸å­˜åœ¨');
      }

      // åŠ å¯†æ–°å¯†ç 
      const bcrypt = require('bcryptjs');
      const hashedPassword = await bcrypt.hash(newPassword, 10);

      // æ›´æ–°å¯†ç 
      await user.update({ password_hash: hashedPassword });

      logger.info('ç®¡ç†å‘˜é‡ç½®ç”¨æˆ·å¯†ç æˆåŠŸ', { 
        adminId: req.user.id,
        targetUserId: id,
        targetEmail: user.email
      });

      return ResponseHelper.success(res, null, 'å¯†ç é‡ç½®æˆåŠŸ');
    } catch (error) {
      logger.error('é‡ç½®ç”¨æˆ·å¯†ç å¤±è´¥', { 
        adminId: req.user?.id, 
        userId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'å¯†ç é‡ç½®å¤±è´¥');
    }
  }


  static async deleteUserGroup(req, res) {
    try {
      const { id } = req.params;

      await User.deleteGroup(id);

      logger.info('åˆ é™¤ç”¨æˆ·åˆ†ç»„æˆåŠŸ', { 
        adminId: req.user.id,
        deletedGroupId: id
      });

      return ResponseHelper.success(res, null, 'ç”¨æˆ·åˆ†ç»„åˆ é™¤æˆåŠŸ');
    } catch (error) {
      logger.error('åˆ é™¤ç”¨æˆ·åˆ†ç»„å¤±è´¥', { 
        adminId: req.user?.id, 
        groupId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, error.message.includes('è¯¥åˆ†ç»„ä¸‹è¿˜æœ‰') ? error.message : 'åˆ é™¤ç”¨æˆ·åˆ†ç»„å¤±è´¥');
    }
  }

  // ===== AIæ¨¡å‹ç®¡ç† (ç§»é™¤maxTokenç›¸å…³) =====

  /**
   * è·å–AIæ¨¡å‹åˆ—è¡¨
   */
  static async getAIModels(req, res) {
    try {
      const sql = `
        SELECT *, 
        (SELECT COUNT(*) FROM conversations WHERE model_name = ai_models.name) as usage_count
        FROM ai_models 
        ORDER BY sort_order ASC, created_at ASC
      `;
      
      const { rows } = await dbConnection.query(sql);
      
      const models = rows.map(row => {
        const model = new AIModel(row);
        if (typeof model.model_config === 'string') {
          try {
            model.model_config = JSON.parse(model.model_config);
          } catch (e) {
            model.model_config = {};
          }
        }
        return model;
      });

      logger.info('è·å–AIæ¨¡å‹åˆ—è¡¨æˆåŠŸ', { 
        adminId: req.user.id,
        modelCount: models.length
      });

      return ResponseHelper.success(res, models, 'è·å–AIæ¨¡å‹åˆ—è¡¨æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–AIæ¨¡å‹åˆ—è¡¨å¤±è´¥', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, 'è·å–AIæ¨¡å‹åˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * åˆ›å»ºAIæ¨¡å‹
   */
  static async createAIModel(req, res) {
    try {
      const modelData = req.body;
      const model = await AIModel.create(modelData);

      logger.info('åˆ›å»ºAIæ¨¡å‹æˆåŠŸ', { 
        adminId: req.user.id,
        modelId: model.id,
        modelName: model.name
      });

      return ResponseHelper.success(res, model.toJSON(), 'AIæ¨¡å‹åˆ›å»ºæˆåŠŸ', 201);
    } catch (error) {
      logger.error('åˆ›å»ºAIæ¨¡å‹å¤±è´¥', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, 'åˆ›å»ºAIæ¨¡å‹å¤±è´¥');
    }
  }

  /**
   * ğŸ”¥ æ›´æ–°AIæ¨¡å‹ (ä¿®å¤Bug: ç¡®ä¿è¿”å›å®Œæ•´æ¨¡å‹æ•°æ®)
   */
  static async updateAIModel(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const model = await AIModel.findById(id);
      if (!model) {
        return ResponseHelper.notFound(res, 'AIæ¨¡å‹ä¸å­˜åœ¨');
      }

      // ğŸ”¥ æ‰§è¡Œæ›´æ–°æ“ä½œ
      await model.update(updateData);
      
      // ğŸ”¥ é‡æ–°è·å–æ›´æ–°åçš„å®Œæ•´æ¨¡å‹æ•°æ®
      const updatedModel = await AIModel.findById(id);
      if (!updatedModel) {
        logger.error('æ›´æ–°åé‡æ–°è·å–æ¨¡å‹å¤±è´¥', { modelId: id });
        return ResponseHelper.error(res, 'æ›´æ–°åè·å–æ¨¡å‹æ•°æ®å¤±è´¥');
      }

      logger.info('æ›´æ–°AIæ¨¡å‹æˆåŠŸ', { 
        adminId: req.user.id,
        modelId: id,
        updateFields: Object.keys(updateData),
        streamEnabled: updatedModel.stream_enabled
      });

      // ğŸ”¥ è¿”å›å®Œæ•´çš„æ¨¡å‹JSONæ•°æ®
      return ResponseHelper.success(res, updatedModel.toJSON(), 'AIæ¨¡å‹æ›´æ–°æˆåŠŸ');
    } catch (error) {
      logger.error('æ›´æ–°AIæ¨¡å‹å¤±è´¥', { 
        adminId: req.user?.id, 
        modelId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'æ›´æ–°AIæ¨¡å‹å¤±è´¥');
    }
  }

  /**
   * åˆ é™¤AIæ¨¡å‹
   */
  static async deleteAIModel(req, res) {
    try {
      const { id } = req.params;

      const model = await AIModel.findById(id);
      if (!model) {
        return ResponseHelper.notFound(res, 'AIæ¨¡å‹ä¸å­˜åœ¨');
      }

      await model.delete();

      logger.info('åˆ é™¤AIæ¨¡å‹æˆåŠŸ', { 
        adminId: req.user.id,
        deletedModelId: id,
        deletedModelName: model.name
      });

      return ResponseHelper.success(res, null, 'AIæ¨¡å‹åˆ é™¤æˆåŠŸ');
    } catch (error) {
      logger.error('åˆ é™¤AIæ¨¡å‹å¤±è´¥', { 
        adminId: req.user?.id, 
        modelId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'åˆ é™¤AIæ¨¡å‹å¤±è´¥');
    }
  }

  /**
   * æµ‹è¯•AIæ¨¡å‹è¿é€šæ€§
   */
  static async testAIModel(req, res) {
    try {
      const { id } = req.params;

      const model = await AIModel.findById(id);
      if (!model) {
        return ResponseHelper.notFound(res, 'AIæ¨¡å‹ä¸å­˜åœ¨');
      }

      const testResult = await model.testConnection();

      logger.info('AIæ¨¡å‹è¿é€šæ€§æµ‹è¯•å®Œæˆ', { 
        adminId: req.user.id,
        modelId: id,
        testSuccess: testResult.success
      });

      return ResponseHelper.success(res, testResult, 'è¿é€šæ€§æµ‹è¯•å®Œæˆ');
    } catch (error) {
      logger.error('AIæ¨¡å‹è¿é€šæ€§æµ‹è¯•å¤±è´¥', { 
        adminId: req.user?.id, 
        modelId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'è¿é€šæ€§æµ‹è¯•å¤±è´¥');
    }
  }

  /**
   * è·å–ç³»ç»Ÿè®¾ç½® - ç§»é™¤maxTokenç›¸å…³è®¾ç½®
   */
  static async getSystemSettings(req, res) {
    try {
      const settings = {
        site: {
          name: 'AI Platform',
          description: 'ä¼ä¸šçº§AIåº”ç”¨èšåˆå¹³å°',
          logo: '',
          favicon: ''
        },
        user: {
          allow_register: true,
          email_verification: false,
          default_token_quota: 10000,
          default_group_id: 1,
          default_credits_quota: 1000
        },
        ai: {
          default_model: 'gpt-3.5-turbo',
          temperature: 0.7
          // ç§»é™¤ max_tokens è®¾ç½®
        },
        credits: {
          enable_credits: true,
          default_credits: 1000,
          max_credits: 100000,
          min_credits_for_chat: 1
        },
        security: {
          session_timeout: 720,
          max_login_attempts: 5,
          enable_rate_limit: true
        }
      };

      return ResponseHelper.success(res, settings, 'è·å–ç³»ç»Ÿè®¾ç½®æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–ç³»ç»Ÿè®¾ç½®å¤±è´¥', { 
        userId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, 'è·å–ç³»ç»Ÿè®¾ç½®å¤±è´¥');
    }
  }

  /**
   * æ›´æ–°ç³»ç»Ÿè®¾ç½®
   */
  static async updateSystemSettings(req, res) {
    try {
      const settings = req.body;

      logger.info('ç®¡ç†å‘˜æ›´æ–°ç³»ç»Ÿè®¾ç½®', { 
        adminId: req.user.id,
        settings
      });

      return ResponseHelper.success(res, settings, 'ç³»ç»Ÿè®¾ç½®æ›´æ–°æˆåŠŸ');
    } catch (error) {
      logger.error('æ›´æ–°ç³»ç»Ÿè®¾ç½®å¤±è´¥', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, 'æ›´æ–°ç³»ç»Ÿè®¾ç½®å¤±è´¥');
    }
  }

  /**
   * è·å–ç³»ç»Ÿæ¨¡å—åˆ—è¡¨
   */
  static async getModules(req, res) {
    try {
      const sql = `
        SELECT 
          id, name, display_name, description, module_type,
          api_endpoint, frontend_url, proxy_path, auth_mode,
          is_active, sort_order, permissions, config,
          health_check_url, status, last_check_at,
          created_at, updated_at
        FROM system_modules 
        ORDER BY sort_order ASC, created_at ASC
      `;
      
      const { rows: modules } = await dbConnection.query(sql);

      logger.info('è·å–ç³»ç»Ÿæ¨¡å—åˆ—è¡¨æˆåŠŸ', { 
        adminId: req.user.id,
        moduleCount: modules.length
      });

      return ResponseHelper.success(res, modules, 'è·å–ç³»ç»Ÿæ¨¡å—åˆ—è¡¨æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–ç³»ç»Ÿæ¨¡å—åˆ—è¡¨å¤±è´¥', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, 'è·å–ç³»ç»Ÿæ¨¡å—åˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * åˆ›å»ºç³»ç»Ÿæ¨¡å—
   */
  static async createModule(req, res) {
    try {
      const {
        name,
        display_name,
        description,
        module_type = 'fullstack',
        api_endpoint,
        frontend_url,
        proxy_path,
        auth_mode = 'jwt',
        permissions = [],
        config = {}
      } = req.body;

      const sql = `
        INSERT INTO system_modules 
        (name, display_name, description, module_type, api_endpoint, frontend_url, 
         proxy_path, auth_mode, permissions, config, is_active, sort_order)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0, 
          (SELECT COALESCE(MAX(sort_order), 0) + 1 FROM system_modules m))
      `;
      
      const { rows } = await dbConnection.query(sql, [
        name, display_name, description, module_type,
        api_endpoint, frontend_url, proxy_path, auth_mode,
        JSON.stringify(permissions), JSON.stringify(config)
      ]);

      const moduleId = rows.insertId;

      logger.info('åˆ›å»ºç³»ç»Ÿæ¨¡å—æˆåŠŸ', { 
        adminId: req.user.id,
        moduleId,
        moduleName: name
      });

      const { rows: [newModule] } = await dbConnection.query(
        'SELECT * FROM system_modules WHERE id = ?', [moduleId]
      );

      return ResponseHelper.success(res, newModule, 'ç³»ç»Ÿæ¨¡å—åˆ›å»ºæˆåŠŸ', 201);
    } catch (error) {
      logger.error('åˆ›å»ºç³»ç»Ÿæ¨¡å—å¤±è´¥', { 
        adminId: req.user?.id, 
        error: error.message 
      });
      return ResponseHelper.error(res, 'åˆ›å»ºç³»ç»Ÿæ¨¡å—å¤±è´¥');
    }
  }

  /**
   * æ›´æ–°ç³»ç»Ÿæ¨¡å—
   */
  static async updateModule(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const allowedFields = [
        'display_name', 'description', 'module_type', 'api_endpoint',
        'frontend_url', 'proxy_path', 'auth_mode', 'is_active', 
        'sort_order', 'permissions', 'config', 'health_check_url'
      ];

      const updateFields = [];
      const updateValues = [];

      allowedFields.forEach(field => {
        if (updateData.hasOwnProperty(field)) {
          updateFields.push(`${field} = ?`);
          
          if (field === 'permissions' || field === 'config') {
            updateValues.push(JSON.stringify(updateData[field]));
          } else {
            updateValues.push(updateData[field]);
          }
        }
      });

      if (updateFields.length === 0) {
        return ResponseHelper.validation(res, ['æ²¡æœ‰æœ‰æ•ˆçš„æ›´æ–°å­—æ®µ']);
      }

      updateFields.push('updated_at = CURRENT_TIMESTAMP');
      updateValues.push(id);

      const sql = `UPDATE system_modules SET ${updateFields.join(', ')} WHERE id = ?`;
      await dbConnection.query(sql, updateValues);

      logger.info('æ›´æ–°ç³»ç»Ÿæ¨¡å—æˆåŠŸ', { 
        adminId: req.user.id,
        moduleId: id,
        updateFields: Object.keys(updateData)
      });

      const { rows: [updatedModule] } = await dbConnection.query(
        'SELECT * FROM system_modules WHERE id = ?', [id]
      );

      return ResponseHelper.success(res, updatedModule, 'ç³»ç»Ÿæ¨¡å—æ›´æ–°æˆåŠŸ');
    } catch (error) {
      logger.error('æ›´æ–°ç³»ç»Ÿæ¨¡å—å¤±è´¥', { 
        adminId: req.user?.id, 
        moduleId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'æ›´æ–°ç³»ç»Ÿæ¨¡å—å¤±è´¥');
    }
  }

  /**
   * åˆ é™¤ç³»ç»Ÿæ¨¡å—
   */
  static async deleteModule(req, res) {
    try {
      const { id } = req.params;

      const { rows: [module] } = await dbConnection.query(
        'SELECT name FROM system_modules WHERE id = ?', [id]
      );

      if (!module) {
        return ResponseHelper.notFound(res, 'ç³»ç»Ÿæ¨¡å—ä¸å­˜åœ¨');
      }

      await dbConnection.query('DELETE FROM system_modules WHERE id = ?', [id]);

      logger.info('åˆ é™¤ç³»ç»Ÿæ¨¡å—æˆåŠŸ', { 
        adminId: req.user.id,
        deletedModuleId: id,
        deletedModuleName: module.name
      });

      return ResponseHelper.success(res, null, 'ç³»ç»Ÿæ¨¡å—åˆ é™¤æˆåŠŸ');
    } catch (error) {
      logger.error('åˆ é™¤ç³»ç»Ÿæ¨¡å—å¤±è´¥', { 
        adminId: req.user?.id, 
        moduleId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'åˆ é™¤ç³»ç»Ÿæ¨¡å—å¤±è´¥');
    }
  }

  /**
   * æµ‹è¯•æ¨¡å—å¥åº·çŠ¶æ€
   */
  static async checkModuleHealth(req, res) {
    try {
      const { id } = req.params;

      const { rows: [module] } = await dbConnection.query(
        'SELECT * FROM system_modules WHERE id = ?', [id]
      );

      if (!module) {
        return ResponseHelper.notFound(res, 'ç³»ç»Ÿæ¨¡å—ä¸å­˜åœ¨');
      }

      let status = 'unknown';
      let message = 'æœªé…ç½®å¥åº·æ£€æŸ¥åœ°å€';

      if (module.health_check_url) {
        try {
          status = 'online';
          message = 'æ¨¡å—è¿è¡Œæ­£å¸¸';
        } catch (error) {
          status = 'offline';
          message = `å¥åº·æ£€æŸ¥å¤±è´¥: ${error.message}`;
        }
      }

      await dbConnection.query(
        'UPDATE system_modules SET status = ?, last_check_at = CURRENT_TIMESTAMP WHERE id = ?',
        [status, id]
      );

      const result = { status, message, checked_at: new Date() };

      logger.info('æ¨¡å—å¥åº·æ£€æŸ¥å®Œæˆ', { 
        adminId: req.user.id,
        moduleId: id,
        status
      });

      return ResponseHelper.success(res, result, 'æ¨¡å—å¥åº·æ£€æŸ¥å®Œæˆ');
    } catch (error) {
      logger.error('æ¨¡å—å¥åº·æ£€æŸ¥å¤±è´¥', { 
        adminId: req.user?.id, 
        moduleId: req.params.id,
        error: error.message 
      });
      return ResponseHelper.error(res, 'æ¨¡å—å¥åº·æ£€æŸ¥å¤±è´¥');
    }
  }
}

module.exports = AdminController;

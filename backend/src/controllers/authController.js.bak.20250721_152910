/**
 * 认证控制器
 */

const User = require('../models/User');
const SystemConfig = require('../models/SystemConfig');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const ResponseHelper = require('../utils/response');
const config = require('../config');
const logger = require('../utils/logger');
const redisConnection = require('../database/redis');
const { ValidationError } = require('../utils/errors');

class AuthController {
  /**
   * 用户登录
   * POST /api/auth/login
   */
  static async login(req, res) {
    try {
      const { email, password } = req.body;

      // 验证输入
      if (!email || !password) {
        return ResponseHelper.validation(res, ['邮箱和密码不能为空']);
      }

      logger.info('用户登录尝试', { email });

      // 查找用户
      const user = await User.findByEmail(email.toLowerCase());
      if (!user) {
        logger.warn('登录失败：用户不存在', { email });
        return ResponseHelper.unauthorized(res, '邮箱或密码错误');
      }

      // 验证密码（使用bcrypt）
      const isPasswordValid = await bcrypt.compare(password, user.password_hash);
      if (!isPasswordValid) {
        logger.warn('登录失败：密码错误', { email, userId: user.id });
        return ResponseHelper.unauthorized(res, '邮箱或密码错误');
      }

      // 检查用户状态
      if (user.status !== 'active') {
        logger.warn('登录失败：用户状态异常', { 
          email, 
          userId: user.id, 
          status: user.status 
        });
        return ResponseHelper.unauthorized(res, '账户已被禁用');
      }

      // 获取用户权限
      const permissions = await user.getPermissions();

      // 生成JWT令牌
      const tokenPayload = {
        userId: user.id,
        email: user.email,
        username: user.username,
        role: user.role,
        type: 'access'
      };
      
      // 添加唯一标识符，用于token管理
      const jti = `${user.id}-${Date.now()}-${Math.random().toString(36).substring(2)}`;
      tokenPayload.jti = jti;

      const accessToken = jwt.sign(
        tokenPayload,
        config.auth.jwt.accessSecret,
        {
          expiresIn: config.auth.jwt.accessExpiresIn,
          issuer: config.auth.jwt.issuer,
          audience: config.auth.jwt.audience
        }
      );

      const refreshToken = jwt.sign(
        {
          userId: user.id,
          type: 'refresh',
          jti: `refresh-${jti}`
        },
        config.auth.jwt.refreshSecret,
        {
          expiresIn: config.auth.jwt.refreshExpiresIn,
          issuer: config.auth.jwt.issuer,
          audience: config.auth.jwt.audience
        }
      );

      // 更新用户最后登录时间
      await user.updateLastLogin();

      logger.info('用户登录成功', { 
        email, 
        userId: user.id, 
        role: user.role,
        permissions: permissions.length
      });

      return ResponseHelper.success(res, {
        user: user.toJSON(),
        permissions,
        accessToken,
        refreshToken,
        expiresIn: config.auth.jwt.accessExpiresIn
      }, '登录成功');

    } catch (error) {
      logger.error('登录处理失败:', error);
      return ResponseHelper.error(res, '登录失败');
    }
  }

  /**
   * 用户注册
   * POST /api/auth/register
   */
  static async register(req, res) {
    try {
      const { email, username, password } = req.body;

      // 验证输入
      if (!email || !username || !password) {
        return ResponseHelper.validation(res, ['邮箱、用户名和密码不能为空']);
      }

      if (password.length < 6) {
        return ResponseHelper.validation(res, ['密码长度至少6位']);
      }

      logger.info('用户注册尝试', { email, username });

      // 检查邮箱是否已存在
      const existingUser = await User.findByEmail(email.toLowerCase());
      if (existingUser) {
        return ResponseHelper.validation(res, ['邮箱已被注册']);
      }

      // 加密密码
      const saltRounds = 10;
      const hashedPassword = await bcrypt.hash(password, saltRounds);

      // 从系统配置获取默认值
      let defaultTokenQuota = 10000;
      let defaultCreditsQuota = 1000;
      let defaultGroupId = 1;
      
      try {
        const systemSettings = await SystemConfig.getFormattedSettings();
        
        if (systemSettings.user) {
          defaultTokenQuota = systemSettings.user.default_token_quota || 10000;
          defaultCreditsQuota = systemSettings.user.default_credits_quota || 1000;
          defaultGroupId = systemSettings.user.default_group_id || 1;
        }
        
        if (systemSettings.credits) {
          // 如果credits配置中有default_credits，优先使用
          defaultCreditsQuota = systemSettings.credits.default_credits || defaultCreditsQuota;
        }
        
        logger.info('使用系统配置的默认值', {
          defaultTokenQuota,
          defaultCreditsQuota,
          defaultGroupId
        });
      } catch (configError) {
        logger.warn('获取系统配置失败，使用默认值', { error: configError.message });
      }

      // 创建用户（使用系统配置的默认值）
      const user = await User.create({
        email: email.toLowerCase(),
        username,
        password: hashedPassword, // 使用加密后的密码
        role: 'user',
        status: 'active',
        group_id: defaultGroupId,
        token_quota: defaultTokenQuota,
        credits_quota: defaultCreditsQuota,
        credits_expire_days: 365 // 默认365天有效期
      });

      // 获取新用户权限
      const permissions = await user.getPermissions();

      logger.info('用户注册成功', { 
        email, 
        userId: user.id,
        tokenQuota: defaultTokenQuota,
        creditsQuota: defaultCreditsQuota
      });

      return ResponseHelper.success(res, {
        user: user.toJSON(),
        permissions
      }, '注册成功', 201);

    } catch (error) {
      logger.error('注册处理失败:', error);
      return ResponseHelper.error(res, '注册失败');
    }
  }

  /**
   * 获取当前用户信息
   * GET /api/auth/me
   */
  static async getCurrentUser(req, res) {
    try {
      const userId = req.user.id;
      
      const user = await User.findById(userId);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      // 获取用户权限
      const permissions = await user.getPermissions();

      return ResponseHelper.success(res, {
        user: user.toJSON(),
        permissions
      }, '获取用户信息成功');

    } catch (error) {
      logger.error('获取用户信息失败:', error);
      return ResponseHelper.error(res, '获取用户信息失败');
    }
  }

  /**
   * 更新个人信息
   * PUT /api/auth/profile
   */
  static async updateProfile(req, res) {
    try {
      const userId = req.user.id;
      const { username, phone, avatar_url } = req.body;

      // 获取用户
      const user = await User.findById(userId);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      // 准备更新数据
      const updateData = {};
      
      // 验证用户名
      if (username && username !== user.username) {
        // 验证用户名格式
        const usernameRegex = /^[a-zA-Z0-9_-]{3,20}$/;
        if (!usernameRegex.test(username)) {
          return ResponseHelper.validation(res, ['用户名只能包含字母、数字、下划线和横线，长度3-20个字符']);
        }
        
        // 检查用户名是否已存在
        const existingUser = await User.findByUsername(username);
        if (existingUser && existingUser.id !== userId) {
          return ResponseHelper.validation(res, ['用户名已被使用']);
        }
        updateData.username = username;
      }

      // 验证手机号
      if (phone !== undefined) {
        if (phone && !/^1[3-9]\d{9}$/.test(phone)) {
          return ResponseHelper.validation(res, ['手机号格式不正确']);
        }
        updateData.phone = phone || null;
      }

      // 头像URL
      if (avatar_url !== undefined) {
        updateData.avatar_url = avatar_url || null;
      }

      // 如果没有需要更新的内容
      if (Object.keys(updateData).length === 0) {
        return ResponseHelper.success(res, {
          user: user.toJSON()
        }, '无需更新');
      }

      // 更新用户信息
      const updatedUser = await user.update(updateData);

      logger.info('用户信息更新成功', { 
        userId, 
        updateFields: Object.keys(updateData) 
      });

      return ResponseHelper.success(res, {
        user: updatedUser.toJSON()
      }, '个人信息更新成功');

    } catch (error) {
      logger.error('更新个人信息失败:', error);
      return ResponseHelper.error(res, error.message || '更新个人信息失败');
    }
  }

  /**
   * 修改密码
   * PUT /api/auth/password
   */
  static async changePassword(req, res) {
    try {
      const userId = req.user.id;
      const { oldPassword, newPassword } = req.body;

      // 验证输入
      if (!oldPassword || !newPassword) {
        return ResponseHelper.validation(res, ['原密码和新密码不能为空']);
      }

      if (newPassword.length < 6) {
        return ResponseHelper.validation(res, ['新密码长度至少6位']);
      }

      // 获取用户
      const user = await User.findById(userId);
      if (!user) {
        return ResponseHelper.notFound(res, '用户不存在');
      }

      // 验证原密码
      const isOldPasswordValid = await bcrypt.compare(oldPassword, user.password_hash);
      if (!isOldPasswordValid) {
        return ResponseHelper.validation(res, ['原密码错误']);
      }

      // 更新密码（使用password字段，User模型会自动处理加密）
      await user.update({ password: newPassword });

      logger.info('用户密码修改成功', { userId });

      return ResponseHelper.success(res, null, '密码修改成功');

    } catch (error) {
      logger.error('修改密码失败:', error);
      return ResponseHelper.error(res, '修改密码失败');
    }
  }

  /**
   * 获取用户积分历史
   * GET /api/auth/credit-history
   */
  static async getCreditHistory(req, res) {
    try {
      const userId = req.user.id;
      const { page = 1, limit = 20 } = req.query;

      const result = await User.getCreditHistory(userId, {
        page: parseInt(page),
        limit: parseInt(limit)
      });

      return ResponseHelper.success(res, result, '获取积分历史成功');

    } catch (error) {
      logger.error('获取积分历史失败:', error);
      return ResponseHelper.error(res, '获取积分历史失败');
    }
  }

  /**
   * 刷新访问令牌
   * POST /api/auth/refresh
   */
  static async refreshToken(req, res) {
    try {
      const { refreshToken } = req.body;

      if (!refreshToken) {
        return ResponseHelper.unauthorized(res, '刷新令牌不能为空');
      }

      // 验证刷新令牌
      const decoded = jwt.verify(refreshToken, config.auth.jwt.refreshSecret);

      if (decoded.type !== 'refresh') {
        return ResponseHelper.unauthorized(res, '无效的刷新令牌');
      }

      // 检查refresh token是否在黑名单中
      if (decoded.jti && redisConnection.isConnected) {
        const isBlacklisted = await redisConnection.exists(`token_blacklist:${decoded.jti}`);
        if (isBlacklisted) {
          return ResponseHelper.unauthorized(res, '刷新令牌已失效');
        }
      }

      // 获取用户信息
      const user = await User.findById(decoded.userId);
      if (!user || user.status !== 'active') {
        return ResponseHelper.unauthorized(res, '用户不存在或已被禁用');
      }

      // 生成新的访问令牌
      const jti = `${user.id}-${Date.now()}-${Math.random().toString(36).substring(2)}`;
      const newAccessToken = jwt.sign(
        {
          userId: user.id,
          email: user.email,
          username: user.username,
          role: user.role,
          type: 'access',
          jti: jti
        },
        config.auth.jwt.accessSecret,
        {
          expiresIn: config.auth.jwt.accessExpiresIn,
          issuer: config.auth.jwt.issuer,
          audience: config.auth.jwt.audience
        }
      );

      logger.info('令牌刷新成功', { userId: user.id });

      return ResponseHelper.success(res, {
        accessToken: newAccessToken,
        expiresIn: config.auth.jwt.accessExpiresIn
      }, '令牌刷新成功');

    } catch (error) {
      if (error.name === 'TokenExpiredError') {
        return ResponseHelper.unauthorized(res, '刷新令牌已过期');
      }
      logger.error('令牌刷新失败:', error);
      return ResponseHelper.unauthorized(res, '刷新令牌无效或已过期');
    }
  }

  /**
   * 用户登出
   * POST /api/auth/logout
   */
  static async logout(req, res) {
    try {
      const userId = req.user?.id;
      const token = req.token;

      if (!userId || !token) {
        return ResponseHelper.success(res, null, '退出登录成功');
      }

      // 解析token获取jti和过期时间
      const decoded = jwt.decode(token);
      if (decoded && decoded.jti && redisConnection.isConnected) {
        // 计算token剩余有效时间
        const now = Math.floor(Date.now() / 1000);
        const ttl = decoded.exp - now;
        
        if (ttl > 0) {
          // 将token加入黑名单，过期时间与token过期时间一致
          await redisConnection.set(`token_blacklist:${decoded.jti}`, userId, ttl);
          logger.info('Token已加入黑名单', { userId, jti: decoded.jti, ttl });
        }
      }

      logger.info('用户登出成功', { userId });

      return ResponseHelper.success(res, null, '退出登录成功');
    } catch (error) {
      logger.error('登出处理失败:', error);
      // 即使失败也返回成功，避免暴露内部错误
      return ResponseHelper.success(res, null, '退出登录成功');
    }
  }
}

module.exports = AuthController;

const { v4: uuidv4 } = require('uuid');
/**
 * å¯¹è¯æ§åˆ¶å™¨ - é›†æˆç§¯åˆ†æ‰£å‡ç³»ç»Ÿå’ŒåŠ¨æ€ä¸Šä¸‹æ–‡æ•°é‡å’Œtemperatureè®¾ç½®
 */

const Conversation = require('../models/Conversation');
const Message = require('../models/Message');
const AIService = require('../services/aiService');
const AIStreamService = require('../services/aiStreamService');
const User = require('../models/User');
const AIModel = require('../models/AIModel');
const ResponseHelper = require('../utils/response');
const logger = require('../utils/logger');
const { ValidationError, AuthorizationError, NotFoundError } = require('../utils/errors');

class ChatController {
  /**
   * è·å–ç”¨æˆ·çš„ä¼šè¯åˆ—è¡¨
   * GET /api/chat/conversations
   */
  static async getConversations(req, res) {
    try {
      const userId = req.user.id;
      const { page = 1, limit = 20 } = req.query;

      logger.info('è·å–ç”¨æˆ·ä¼šè¯åˆ—è¡¨', { userId, page, limit });

      const result = await Conversation.getUserConversations(userId, {
        page: parseInt(page),
        limit: parseInt(limit)
      });

      return ResponseHelper.paginated(res, result.conversations, result.pagination, 'è·å–ä¼šè¯åˆ—è¡¨æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–ä¼šè¯åˆ—è¡¨å¤±è´¥', { 
        userId: req.user?.id, 
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, 'è·å–ä¼šè¯åˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * åˆ›å»ºæ–°ä¼šè¯ - æ”¯æŒä¸Šä¸‹æ–‡æ•°é‡å’Œtemperatureè®¾ç½®
   * POST /api/chat/conversations
   */
  static async createConversation(req, res) {
    try {
      const userId = req.user.id;
      const { title, model_name, system_prompt, context_length, ai_temperature } = req.body;

      logger.info('å¼€å§‹åˆ›å»ºä¼šè¯', { 
        userId, 
        title, 
        model_name, 
        context_length,
        ai_temperature,
        hasSystemPrompt: !!system_prompt 
      });

      // éªŒè¯æ¨¡å‹åç§°
      if (!model_name) {
        return ResponseHelper.validation(res, ['æ¨¡å‹åç§°ä¸èƒ½ä¸ºç©º']);
      }

      // éªŒè¯AIæ¨¡å‹æ˜¯å¦å­˜åœ¨ä¸”å¯ç”¨
      const aiModel = await AIModel.findByName(model_name);
      if (!aiModel || !aiModel.is_active) {
        return ResponseHelper.validation(res, ['é€‰æ‹©çš„AIæ¨¡å‹ä¸å¯ç”¨']);
      }

      // éªŒè¯ä¸Šä¸‹æ–‡æ•°é‡
      let validContextLength = parseInt(context_length) || 20;
      if (validContextLength < 0) validContextLength = 0;
      if (validContextLength > 1000) validContextLength = 1000;

      // éªŒè¯temperatureå‚æ•°
      let validTemperature = parseFloat(ai_temperature);
      if (isNaN(validTemperature)) validTemperature = 0.0;
      if (validTemperature < 0.0) validTemperature = 0.0;
      if (validTemperature > 1.0) validTemperature = 1.0;

      const conversationData = {
        user_id: parseInt(userId),
        title: title || 'New Chat',
        model_name: model_name || 'gpt-3.5-turbo',
        system_prompt: system_prompt || null,
        context_length: validContextLength,
        ai_temperature: validTemperature
      };

      logger.info('ä¼šè¯æ•°æ®å‡†å¤‡å®Œæˆ', conversationData);

      const conversation = await Conversation.create(conversationData);

      logger.info('ä¼šè¯åˆ›å»ºæˆåŠŸ', { 
        userId, 
        conversationId: conversation.id,
        modelName: conversation.model_name,
        contextLength: conversation.context_length,
        aiTemperature: conversation.ai_temperature
      });

      return ResponseHelper.success(res, conversation.toJSON(), 'ä¼šè¯åˆ›å»ºæˆåŠŸ', 201);
    } catch (error) {
      logger.error('ä¼šè¯åˆ›å»ºå¤±è´¥', { 
        userId: req.user?.id, 
        requestBody: req.body,
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, `ä¼šè¯åˆ›å»ºå¤±è´¥: ${error.message}`);
    }
  }

  /**
   * è·å–ä¼šè¯è¯¦æƒ…
   * GET /api/chat/conversations/:id
   */
  static async getConversation(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;

      // æ£€æŸ¥ä¼šè¯æ‰€æœ‰æƒ
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, 'æ— æƒè®¿é—®æ­¤ä¼šè¯');
      }

      const conversation = await Conversation.findById(id);
      if (!conversation) {
        return ResponseHelper.notFound(res, 'ä¼šè¯ä¸å­˜åœ¨');
      }

      return ResponseHelper.success(res, conversation.toJSON(), 'è·å–ä¼šè¯æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–ä¼šè¯è¯¦æƒ…å¤±è´¥', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, 'è·å–ä¼šè¯å¤±è´¥');
    }
  }

  /**
   * æ›´æ–°ä¼šè¯ - æ”¯æŒä¸Šä¸‹æ–‡æ•°é‡å’Œtemperatureæ›´æ–°
   * PUT /api/chat/conversations/:id
   */
  static async updateConversation(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const { title, model_name, system_prompt, is_pinned, context_length, ai_temperature } = req.body;

      // æ£€æŸ¥ä¼šè¯æ‰€æœ‰æƒ
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, 'æ— æƒä¿®æ”¹æ­¤ä¼šè¯');
      }

      const conversation = await Conversation.findById(id);
      if (!conversation) {
        return ResponseHelper.notFound(res, 'ä¼šè¯ä¸å­˜åœ¨');
      }

      // å¦‚æœæ›´æ¢æ¨¡å‹ï¼ŒéªŒè¯æ–°æ¨¡å‹
      if (model_name && model_name !== conversation.model_name) {
        const aiModel = await AIModel.findByName(model_name);
        if (!aiModel || !aiModel.is_active) {
          return ResponseHelper.validation(res, ['é€‰æ‹©çš„AIæ¨¡å‹ä¸å¯ç”¨']);
        }
      }

      // éªŒè¯ä¸Šä¸‹æ–‡æ•°é‡
      let updateData = { title, model_name, system_prompt, is_pinned };
      
      if (context_length !== undefined) {
        let validContextLength = parseInt(context_length) || 20;
        if (validContextLength < 0) validContextLength = 0;
        if (validContextLength > 1000) validContextLength = 1000;
        updateData.context_length = validContextLength;
      }

      // éªŒè¯temperatureå‚æ•°
      if (ai_temperature !== undefined) {
        let validTemperature = parseFloat(ai_temperature);
        if (isNaN(validTemperature)) validTemperature = 0.0;
        if (validTemperature < 0.0) validTemperature = 0.0;
        if (validTemperature > 1.0) validTemperature = 1.0;
        updateData.ai_temperature = validTemperature;
      }

      const updatedConversation = await conversation.update(updateData);

      logger.info('ä¼šè¯æ›´æ–°æˆåŠŸ', { 
        userId, 
        conversationId: id,
        updateData
      });

      return ResponseHelper.success(res, updatedConversation.toJSON(), 'ä¼šè¯æ›´æ–°æˆåŠŸ');
    } catch (error) {
      logger.error('ä¼šè¯æ›´æ–°å¤±è´¥', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, 'ä¼šè¯æ›´æ–°å¤±è´¥');
    }
  }

  /**
   * åˆ é™¤ä¼šè¯
   * DELETE /api/chat/conversations/:id
   */
  static async deleteConversation(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;

      // æ£€æŸ¥ä¼šè¯æ‰€æœ‰æƒ
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, 'æ— æƒåˆ é™¤æ­¤ä¼šè¯');
      }

      const conversation = await Conversation.findById(id);
      if (!conversation) {
        return ResponseHelper.notFound(res, 'ä¼šè¯ä¸å­˜åœ¨');
      }

      await conversation.delete();

      logger.info('ä¼šè¯åˆ é™¤æˆåŠŸ', { 
        userId, 
        conversationId: id 
      });

      return ResponseHelper.success(res, null, 'ä¼šè¯åˆ é™¤æˆåŠŸ');
    } catch (error) {
      logger.error('ä¼šè¯åˆ é™¤å¤±è´¥', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, 'ä¼šè¯åˆ é™¤å¤±è´¥');
    }
  }

  /**
   * è·å–ä¼šè¯æ¶ˆæ¯
   * GET /api/chat/conversations/:id/messages
   */
  static async getMessages(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const { page = 1, limit = 50 } = req.query;

      // æ£€æŸ¥ä¼šè¯æ‰€æœ‰æƒ
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, 'æ— æƒè®¿é—®æ­¤ä¼šè¯æ¶ˆæ¯');
      }

      const result = await Message.getConversationMessages(id, {
        page: parseInt(page),
        limit: parseInt(limit),
        order: 'ASC'
      });

      return ResponseHelper.paginated(res, result.messages, result.pagination, 'è·å–æ¶ˆæ¯åˆ—è¡¨æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–ä¼šè¯æ¶ˆæ¯å¤±è´¥', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, 'è·å–æ¶ˆæ¯å¤±è´¥');
    }
  }

  /**
   * å‘é€æ¶ˆæ¯å¹¶è·å–AIå›å¤ - é›†æˆç§¯åˆ†æ‰£å‡ç³»ç»Ÿå’ŒåŠ¨æ€ä¸Šä¸‹æ–‡å’Œtemperature
   * POST /api/chat/conversations/:id/messages
   */
  static async sendMessage(req, res) {
    let creditsConsumed = 0;
    let conversationBackup = null;
    
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const { content, file_id } = req.body;

      if (!content || content.trim().length === 0) {
        return ResponseHelper.validation(res, ['æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º']);
      }

      // æ£€æŸ¥ä¼šè¯æ‰€æœ‰æƒ
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, 'æ— æƒåœ¨æ­¤ä¼šè¯ä¸­å‘é€æ¶ˆæ¯');
      }

      const conversation = await Conversation.findById(id);
      if (!conversation) {
        return ResponseHelper.notFound(res, 'ä¼šè¯ä¸å­˜åœ¨');
      }

      // ğŸ”¥ è·å–AIæ¨¡å‹ç§¯åˆ†é…ç½®
      const aiModel = await AIModel.findByName(conversation.model_name);
      if (!aiModel || !aiModel.is_active) {
        return ResponseHelper.error(res, 'å½“å‰AIæ¨¡å‹ä¸å¯ç”¨');
      }

      const requiredCredits = aiModel.credits_per_chat || 10;
      
      // ğŸ”¥ æ£€æŸ¥ç”¨æˆ·ç§¯åˆ†ä½™é¢
      const user = await User.findById(userId);
      if (!user.hasCredits(requiredCredits)) {
        return ResponseHelper.forbidden(res, `ç§¯åˆ†ä¸è¶³ï¼Œéœ€è¦ ${requiredCredits} ç§¯åˆ†ï¼Œå½“å‰ä½™é¢ ${user.getCredits()} ç§¯åˆ†`);
      }

      // æ£€æŸ¥ç”¨æˆ·Tokené…é¢
      const estimatedTokens = Message.estimateTokens(content);
      if (!user.hasTokenQuota(estimatedTokens * 2)) { // ä¼°ç®—è¯·æ±‚å’Œå“åº”Token
        return ResponseHelper.forbidden(res, 'Tokené…é¢ä¸è¶³');
      }

      // å¤‡ä»½å¯¹è¯çŠ¶æ€ï¼Œç”¨äºå¤±è´¥å›æ»š
      conversationBackup = {
        message_count: conversation.message_count,
        total_tokens: conversation.total_tokens
      };

      logger.info('é¢„æ‰£å‡ç§¯åˆ†å¼€å§‹', {
        userId,
        conversationId: id,
        modelName: conversation.model_name,
        contextLength: conversation.getContextLength(),
        aiTemperature: conversation.getTemperature(),
        requiredCredits,
        currentBalance: user.getCredits()
      });

      // ğŸ”¥ é¢„å…ˆæ‰£å‡ç§¯åˆ† - é˜²æ­¢å¹¶å‘é‡å¤æ¶ˆè´¹
      const creditsResult = await user.consumeCredits(
        requiredCredits, 
        aiModel.id, 
        id, 
        `AIå¯¹è¯æ¶ˆè´¹ - ${aiModel.display_name}`
      );
      
      creditsConsumed = requiredCredits;

      logger.info('ç§¯åˆ†é¢„æ‰£å‡æˆåŠŸ', {
        userId,
        conversationId: id,
        creditsConsumed,
        balanceAfter: creditsResult.balanceAfter
      });

      // åˆ›å»ºç”¨æˆ·æ¶ˆæ¯
      const userMessage = await Message.create({
        conversation_id: id,
        role: 'user',
        content: content.trim(),
        tokens: estimatedTokens,
        file_id
      });

      // ğŸ”¥ è·å–ä¼šè¯å†å²æ¶ˆæ¯ç”¨äºAIä¸Šä¸‹æ–‡ - ä½¿ç”¨ä¼šè¯é…ç½®çš„ä¸Šä¸‹æ–‡æ•°é‡
      const recentMessages = await Message.getRecentMessages(id); // è‡ªåŠ¨ä½¿ç”¨ä¼šè¯çš„context_lengthé…ç½®
      
      // æ„é€ AIè¯·æ±‚æ¶ˆæ¯
      const aiMessages = [];
      
      // æ·»åŠ ç³»ç»Ÿæç¤ºè¯
      if (conversation.system_prompt) {
        aiMessages.push({
          role: 'system',
          content: conversation.system_prompt
        });
      }
      
      // æ·»åŠ å†å²æ¶ˆæ¯
      recentMessages.forEach(msg => {
        aiMessages.push(msg.toAIFormat());
      });

      logger.info('å‘é€AIè¯·æ±‚', { 
        userId,
        conversationId: id,
        modelName: conversation.model_name,
        contextLength: conversation.getContextLength(),
        aiTemperature: conversation.getTemperature(),
        messageCount: aiMessages.length,
        creditsCharged: requiredCredits
      });

      try {
        // ğŸ”¥ è°ƒç”¨AIæœåŠ¡ - ä¼ é€’ä¼šè¯çº§temperature
        const aiResponse = await AIService.sendMessage(
          conversation.model_name,
          aiMessages,
          { temperature: conversation.getTemperature() }
        );

        // åˆ›å»ºAIå›å¤æ¶ˆæ¯
        const assistantMessage = await Message.create({
          conversation_id: id,
          role: 'assistant',
          content: aiResponse.content,
          tokens: aiResponse.usage?.completion_tokens || Message.estimateTokens(aiResponse.content)
        });

        // æ›´æ–°ä¼šè¯ç»Ÿè®¡
        const totalTokens = userMessage.tokens + assistantMessage.tokens;
        await conversation.updateStats(2, totalTokens);

        // æ›´æ–°ç”¨æˆ·Tokenä½¿ç”¨é‡
        await user.updateTokenUsage(totalTokens);

        // å¦‚æœæ˜¯ç¬¬ä¸€æ¡æ¶ˆæ¯ä¸”æ ‡é¢˜æ˜¯é»˜è®¤çš„ï¼Œè‡ªåŠ¨ç”Ÿæˆæ ‡é¢˜
        if (conversation.title === 'New Chat' && conversation.message_count === 0) {
          const autoTitle = content.substring(0, 30) + (content.length > 30 ? '...' : '');
          await conversation.update({ title: autoTitle });
        }

        logger.info('AIå¯¹è¯æˆåŠŸå®Œæˆ', { 
          userId,
          conversationId: id,
          contextLength: conversation.getContextLength(),
          aiTemperature: conversation.getTemperature(),
          requestTokens: userMessage.tokens,
          responseTokens: assistantMessage.tokens,
          totalTokens,
          creditsConsumed,
          balanceAfter: creditsResult.balanceAfter
        });

        return ResponseHelper.success(res, {
          user_message: userMessage.toJSON(),
          assistant_message: assistantMessage.toJSON(),
          conversation: conversation.toJSON(),
          usage: {
            total_tokens: totalTokens,
            user_tokens: userMessage.tokens,
            assistant_tokens: assistantMessage.tokens
          },
          credits_info: {
            credits_consumed: creditsConsumed,
            credits_remaining: creditsResult.balanceAfter,
            model_credits_per_chat: requiredCredits
          }
        }, 'AIå¯¹è¯å®Œæˆ');

      } catch (aiError) {
        // ğŸ”¥ AIè°ƒç”¨å¤±è´¥ï¼Œé€€è¿˜ç§¯åˆ†
        logger.error('AIè°ƒç”¨å¤±è´¥ï¼Œå¼€å§‹é€€è¿˜ç§¯åˆ†', {
          userId,
          conversationId: id,
          creditsToRefund: creditsConsumed,
          aiError: aiError.message
        });

        try {
          // é€€è¿˜ç§¯åˆ† - å¢åŠ é…é¢
          await user.addCredits(creditsConsumed, `AIè°ƒç”¨å¤±è´¥é€€æ¬¾ - ${aiError.message}`);
          
          logger.info('ç§¯åˆ†é€€è¿˜æˆåŠŸ', {
            userId,
            creditsRefunded: creditsConsumed
          });

        } catch (refundError) {
          logger.error('ç§¯åˆ†é€€è¿˜å¤±è´¥', {
            userId,
            creditsToRefund: creditsConsumed,
            refundError: refundError.message
          });
        }

        // æŠ›å‡ºåŸå§‹AIé”™è¯¯
        throw aiError;
      }

    } catch (error) {
      logger.error('å‘é€æ¶ˆæ¯å¤±è´¥', { 
        conversationId: req.params.id,
        userId: req.user?.id, 
        creditsConsumed,
        error: error.message,
        stack: error.stack
      });

      return ResponseHelper.error(res, error.message || 'æ¶ˆæ¯å‘é€å¤±è´¥');
    }
  }

  /**
   * å‘é€æµå¼æ¶ˆæ¯ - æ–°å¢æµå¼å¤„ç†æ–¹æ³•
   * POST /api/chat/stream-messages/:id
   */
  static async sendStreamMessage(req, res) {
    let creditsConsumed = 0;
    let userMessage = null;
    let aiMessageId = null;
    
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const { content, file_id } = req.body;

      if (!content || content.trim().length === 0) {
        return ResponseHelper.validation(res, ['æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º']);
      }

      // æ£€æŸ¥ä¼šè¯æ‰€æœ‰æƒ
      const hasAccess = await Conversation.checkOwnership(id, userId);
      if (!hasAccess) {
        return ResponseHelper.forbidden(res, 'æ— æƒåœ¨æ­¤ä¼šè¯ä¸­å‘é€æ¶ˆæ¯');
      }

      const conversation = await Conversation.findById(id);
      if (!conversation) {
        return ResponseHelper.notFound(res, 'ä¼šè¯ä¸å­˜åœ¨');
      }

      // è·å–AIæ¨¡å‹é…ç½®
      const aiModel = await AIModel.findByName(conversation.model_name);
      if (!aiModel || !aiModel.is_active) {
        return ResponseHelper.error(res, 'å½“å‰AIæ¨¡å‹ä¸å¯ç”¨');
      }

      // æ£€æŸ¥æ¨¡å‹æ˜¯å¦æ”¯æŒæµå¼è¾“å‡º
      if (!aiModel.stream_enabled) {
        return ResponseHelper.error(res, 'å½“å‰AIæ¨¡å‹ä¸æ”¯æŒæµå¼è¾“å‡º');
      }

      const requiredCredits = aiModel.credits_per_chat || 10;
      
      // æ£€æŸ¥ç”¨æˆ·ç§¯åˆ†
      const user = await User.findById(userId);
      if (!user.hasCredits(requiredCredits)) {
        return ResponseHelper.forbidden(res, `ç§¯åˆ†ä¸è¶³ï¼Œéœ€è¦ ${requiredCredits} ç§¯åˆ†ï¼Œå½“å‰ä½™é¢ ${user.getCredits()} ç§¯åˆ†`);
      }

      // é¢„æ‰£å‡ç§¯åˆ†
      const creditsResult = await user.consumeCredits(
        requiredCredits, 
        aiModel.id, 
        id, 
        `æµå¼AIå¯¹è¯æ¶ˆè´¹ - ${aiModel.display_name}`
      );
      
      creditsConsumed = requiredCredits;

      // åˆ›å»ºç”¨æˆ·æ¶ˆæ¯
      userMessage = await Message.create({
        conversation_id: id,
        role: 'user',
        content: content.trim(),
        tokens: Message.estimateTokens(content),
        file_id
      });

      // è·å–ä¼šè¯å†å²
      const recentMessages = await Message.getRecentMessages(id);
      
      // æ„é€ AIè¯·æ±‚æ¶ˆæ¯
      const aiMessages = [];
      if (conversation.system_prompt) {
        aiMessages.push({
          role: 'system',
          content: conversation.system_prompt
        });
      }
      recentMessages.forEach(msg => {
        aiMessages.push(msg.toAIFormat());
      });

      // é¢„åˆ›å»ºAIæ¶ˆæ¯ID
      const uuid = require('uuid');
      aiMessageId = uuidv4();

      // è®¾ç½®SSEè¿æ¥
      logger.info('å¼€å§‹æµå¼AIå¯¹è¯', { 
        userId,
        conversationId: id,
        modelName: conversation.model_name,
        messageId: aiMessageId
      });

      // è°ƒç”¨æµå¼AIæœåŠ¡
      await AIStreamService.sendStreamMessage(res, conversation.model_name, aiMessages, {
        temperature: conversation.getTemperature(),
        messageId: aiMessageId,
        conversationId: id,
        userId: userId,
        onComplete: async (fullContent, tokens) => {
          // æµå¼å®Œæˆåä¿å­˜AIæ¶ˆæ¯
          try {
            const assistantMessage = await Message.create({
              id: aiMessageId,
              conversation_id: id,
              role: 'assistant',
              content: fullContent,
              tokens: tokens || AIStreamService.estimateStreamTokens(fullContent)
            });

            // æ›´æ–°ä¼šè¯ç»Ÿè®¡
            const totalTokens = userMessage.tokens + assistantMessage.tokens;
            await conversation.updateStats(2, totalTokens);
            await user.updateTokenUsage(totalTokens);

            logger.info('æµå¼AIå¯¹è¯å®Œæˆ', { 
              userId,
              conversationId: id,
              messageId: aiMessageId,
              totalTokens,
              creditsConsumed
            });
          } catch (error) {
            logger.error('ä¿å­˜æµå¼æ¶ˆæ¯å¤±è´¥:', error);
          }
        }
      });

    } catch (error) {
      logger.error('æµå¼æ¶ˆæ¯å‘é€å¤±è´¥', { 
        conversationId: req.params.id,
        userId: req.user?.id,
        error: error.message
      });

      // å¦‚æœå·²æ‰£å‡ç§¯åˆ†ï¼Œå°è¯•é€€è¿˜
      if (creditsConsumed > 0) {
        try {
          const user = await User.findById(req.user.id);
          await user.addCredits(creditsConsumed, `æµå¼AIè°ƒç”¨å¤±è´¥é€€æ¬¾ - ${error.message}`);
          logger.info('æµå¼ç§¯åˆ†é€€è¿˜æˆåŠŸ', { userId: req.user.id, creditsRefunded: creditsConsumed });
        } catch (refundError) {
          logger.error('æµå¼ç§¯åˆ†é€€è¿˜å¤±è´¥', { error: refundError.message });
        }
      }

      // å¦‚æœSSEè¿˜æœªè®¾ç½®ï¼Œè¿”å›æ™®é€šé”™è¯¯å“åº”
      if (!res.headersSent) {
        return ResponseHelper.error(res, error.message || 'æµå¼æ¶ˆæ¯å‘é€å¤±è´¥');
      }
    }
  }

  /**
   * è·å–å¯ç”¨çš„AIæ¨¡å‹åˆ—è¡¨ - å¢å¼ºç§¯åˆ†ä¿¡æ¯
   * GET /api/chat/models
   */
  static async getModels(req, res) {
    try {
      const models = await AIService.getAvailableModels();
      
      // æ·»åŠ ç§¯åˆ†ä¿¡æ¯åˆ°æ¨¡å‹åˆ—è¡¨
      const modelsWithCredits = models.map(model => ({
        ...model,
        credits_per_chat: model.credits_per_chat || 10,
        credits_display: `${model.credits_per_chat || 10} ç§¯åˆ†/æ¬¡`
      }));
      
      return ResponseHelper.success(res, modelsWithCredits, 'è·å–AIæ¨¡å‹åˆ—è¡¨æˆåŠŸ');
    } catch (error) {
      logger.error('è·å–AIæ¨¡å‹åˆ—è¡¨å¤±è´¥', { 
        userId: req.user?.id, 
        error: error.message,
        stack: error.stack
      });
      return ResponseHelper.error(res, 'è·å–AIæ¨¡å‹åˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * è·å–ç”¨æˆ·ç§¯åˆ†çŠ¶æ€ - æ–°å¢æ¥å£
   * GET /api/chat/credits
   */
  static async getUserCredits(req, res) {
    try {
      const userId = req.user.id;
      const user = await User.findById(userId);
      
      if (!user) {
        return ResponseHelper.notFound(res, 'ç”¨æˆ·ä¸å­˜åœ¨');
      }
      
      const creditsStats = user.getCreditsStats();
      
      return ResponseHelper.success(res, {
        user_id: userId,
        credits_stats: creditsStats,
        can_chat: user.hasCredits(10) // å‡è®¾æœ€å°éœ€è¦10ç§¯åˆ†
      }, 'è·å–ç”¨æˆ·ç§¯åˆ†çŠ¶æ€æˆåŠŸ');
      
    } catch (error) {
      logger.error('è·å–ç”¨æˆ·ç§¯åˆ†çŠ¶æ€å¤±è´¥', {
        userId: req.user?.id,
        error: error.message
      });
      return ResponseHelper.error(res, 'è·å–ç§¯åˆ†çŠ¶æ€å¤±è´¥');
    }
  }
}

module.exports = ChatController;
